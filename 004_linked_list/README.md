# 추상자료형(Abstract Data Type)
> 구체적인 기능의 완성과정을 언급하지 않고, 순수하게 기능이 무엇인지를 나열한 것을 가리켜, 추상자료형 또는 ADT 라고한다.

- 예시) 지갑의 추상자료형
    - 카드의 삽입
    - 카드의 추출
    - 지폐의 삽입
    - 지폐의 추출

기능의 진행(완성)되는 과정을 언급하지 않고 기능이 무엇인지만 나열하였다. <br>
(`‘이런기능이 있고 이런 기능이 있어’` 기능의 명세!)<br>
<br>

### 자료형의 정의
완전한 자료형의 정의로 인식되기 위해서는 해당 자료형과 관련이 있는 연산이 함께 정의 되어야 한다.<br>
(c언어에서는 이러한 연산을 함수를 이용하여 정의한다.)

```c
Ex.1

// 구조체 기반 자료형 Wallet의 정의

typedef struct _Wallet
{
    int coin100Num;
    int bill5000Num;
} Wallet;

// Wallet을 기반으로 제공할 수 있는 기능 관련 연산의 정의

int TakeOutMoney(Wallet * pw, int coinNum, int billNum);     // 돈을 꺼내는 연산
void PutMoney(Wallet * pw, int coinNum, int billNum);    // 돈을 넣는 연산 
```
‘자료형’의 정의에 ‘기능’ 혹은 ‘연산’과 관련된 내용을 명시할 수 있다.  따라서 추상 자료형이라 하여 그것에 기능 또는 연산과 관련된 내용을<br>
명시할 수 없다는 생각은 버려야 한다.<br>
<br>

### Wallet의 추상 자료형(ADT)
- `int TakeOutMoney(Wallet * pw, int coinNum, int billNum);`
	 
    - 첫 번째 인자로 전달돤 주소의 지갑에서 돈을 꺼낸다.
    - 두 번째 인자로 꺼낼 동전의 수, 세 번째 인자로 꺼낼 지폐의 수를 전달한다.
    - 꺼내고자 하는 돈의 총액이 반환된다. 그리고 그만큼 돈은 차감된다.<br/><br/>
    
- `void PutMoney(Wallet * pw, int coinNum < int billNum);`
    - 첫 번째 인자로 전달된 주소이 지갑에 돈을 넣는다.
    - 두 번째 인자로 넣을 동전의 수, 세 번째 인자로 넣을 지폐의 수를 전달한다.
    - 넣은 만큼 동전과 지폐의 수가 증가한다.<br/><br/>
    
추상 자료형을 명시하는데 있어 명시해야 할 정보인 **기능**을 충분히 묘사하고 있다면 위와 같은 방법도 괜찮다.<br>
추상 자료형에 중요한 정보라면 무엇이든 추가할 수 있으며, 그 방법에는 제한이 없다. 하지만 불필요한 것을 포함시키는 것은 바람직하지 못하다.<br>

<br><br>


# 링크드 리스트(Linked List)
### 배열의 한계
프로그래밍을 하다보면, 배열 이상의 무엇인가를 요구할 때가 생기게 된다. 예들 들어, 디렉토리 내에 있는 파일들의 목록을 소프트웨어가<br>
필요로 한다고 생각해 보자, 이때 한번 생성하면 그 크기를 변경할 수 없는 배열을 사용하게 되면, 다음과 같은 문제가 생기게 된다.<br>

디렉토리 내에 파일의 개수가 하나도 없을 수도 있고, 딱 10개가 존재할 수도 있으며, 수만, 수천개의 파일이 존재할 수도 있다.<br>
이러한 상황에서 배열을 사용한다고 생각해 보자.<br>

> 제발 디렉토리 안에 10개의 파일만 있어라.. 라고 빌면서 다음과 같이 배열을 선언하는 것은 말도 안되는 짓이다.<br>
  `char * files[10];`<br>

> 그렇다고 해서 넉넉잡아 6800개 정도면 충분하겠지? 라고 생각하면서 다음과 같이 무작정 큰 배열을 선언하는 것도 문제가 있다.<br>
  쓸데없이 큰 배열을 생성하게 될 뿐만 아니라, 해당 디렉토리의 파일 수가 6800개 이상일 수도 있기 때문이다.<br>
  `char * files[6800];`<br>

이렇게, 우리는 프로그래밍을 하면서, 데이터의 집합을 보관하는 기능을 가지고는 있지만, 한번 선언하면 <br>
그 크기를 변경할 수 없다는 한계를 가진 배열을 대신할 무언가가 필요한 상황이 생기게 된다.<br>
<br>

### 링크드 리스트의 개념
위에서 다뤄보았던 배열의 한계를 보완하면서, 데이터의 집합을 보관하는 기능을 가지고 있는 자료구조는 무엇이 있을까?<br>
바로 **`리스트(List: 목록)`** 이다.<br>

리스트는 배열처럼 데이터의 집합을 보관하는 기능을 가지면서, 배열과는 달리 유연하게 그 크기도 변경할 수 있는 자료구조이다.<br>

링크드 리스트(Linked List)는 이 리스트를 구현하는 여러가지 기법 중, 가장 간단한 방법이라고 꼽히는 자료구조로,<br>
리스트 내의 각 요소는 노드(Node)라고 하는데, 우리나라 말로 번역하면 '마디' 라는 의미를 가진다.<br>

링크드 리스트는 이 **'노드(마디)를 연결해서 만드는 리스트'** 라고 해서 붙여진 이름이다.<br>
그럼 이 노드는 어떤식으로 이루어져 있을까? 아래 그림을 한번 봐 보자.<br>

![2021-04-03-singly-linked-list-node](https://user-images.githubusercontent.com/83572199/233826489-4417d7f6-3b9d-4dd2-9ed8-fd233bcc9618.svg)<br>

노드는 다음과 같이 데이터를 저장할 수 있는 필드와 다음 노드의 주소값을 저장하는 포인터(다음 노드와 연결해주는 연결고리 역할)로 <br>
이루어져 있다.<br>

이러한 노드를 주렁주렁 엮으면 링크드 리스트 라는 자료구조가 만들어지고,<br>
이 링크드 리스트의 첫 번째 노드가 해당 링크드 리스트의 머리 즉, head가 되며, 링크드 리스트의 마지막 노드가 해당 링크드 리스트의 꼬리, tail이 된다.<br>

이러한 구조로 이루어진 링크드 리스트를 사용하게 되면, 배열과는 다르게 다뤄야할 데이터의 집합의 크기를 미리알지 못한다 해도<br>
문제가 되지 않는다.<br>

해당 링크드 리스트에 데이터를 추가하고 싶으면, 추가하고 싶은만큼 데이터가 늘어날 때마다 tail에 노드를 생성하여 붙이면 되고,<br>
링크드 리스트 중간에 새로운 노드를 끼워넣거나 삭제하고 싶으면, 해당 노드를 가리키는 포인터만 수정해주면 되기 때문이다.<br>
<br>

### 링크드 리스트의 구현
링크드 리스트는 노드가 주렁주렁 엮인 형태라고 설명하였다. 때문에, 링크드 리스트를 구현하기 위해서는 노드를 코드로 표현할 수 있어야 한다.<br>
이 노드를 C언어로 표현하면 다음과 같이 구조체 형태로 표현이 가능하다.<br>

```c
typedef struct tagNode // 구조체 태그이름 tagNode
{
  int Data; // 데이터를 저장하는 필드
  struct tagNode* NextNode; // 다음 노드의 주소값을 저장하는 포인터 (같은 구조체 타입:struct tagNode(Node) 의 노드를 연결해준다.)
} Node;
```
이렇게 선언한 `Node` 구조체는 다음과 같이 인스턴스를 생성 가능하다. 
```c
Node Mynode;
```

<br><br>


## 링크드 리스트의 연산
링크드 리스트를 구축하고, 링트드 리스트의 데이터를 활용하기 위한 주요 연산으로는 다음 5가지가 존재한다. 
- 노드의 생성/소멸
- 노드 추가
- 노드 삭제
- 노드 삽입
- 노드 탐색

노드의 생성/소멸, 추가, 삭제, 삽입은 링크드 리스트의 구축을 위한 연산이고, 노드 탐색은 구촉되어 있는 링크드 리스트의<br>
데이터를 활용하기 위한 연산이다.<br>
<br>

### 노드의 생성/소멸
노드의 생성과 소멸에 대해 이해하기 위해서는 우선적으로, C언어 프로그램의 메모리 영역에 대한 지식이 필요하다.<br>
해당 내용은 다음 링크에서 다루고 있다.<br>
[Memory Area of C Program](https://github.com/Yoonsik-2002/data-structure-study/tree/main/000_other_knowledge/memory_area_of_c_program)<br>

그럼, 링크드 리스트를 이루는 노드는 자동 메모리(스택 영역), 자유 메모리(힙 영역) 중 어디에 생성하는 것이 적절할까?<br>
먼저, 자동 메모리에 노드를 생성해 보겠다. 

- #### 노드를 자동메모리(스택 영역)에 생성하게 되는 경우
  다음은 새로운 노드를 자동메모리에 생성해주는 함수 `SSL_CreateNode` 이다.<br>
  
  ```c
  // 노드생성(실패 버전)
  Node* SSL_CreateNode(int new_data)
  {
    Node NewNode; // 자동 저장소(스택 영역)에 새로운 노드 생성
    
    NewNode.Data = new_data; // 인자로 받은 new_data의 값을 인스턴스의 멤버 Data에 저장
    NewNode.NextNode = Null; // 새로 생성된 노드 NewNode의 다음 노드는 존재하지 않음(Null)
    
    return &NewNode; // NewNode의 주소값 반환
  }
  ...
  Node* MyNode = SSL_CreateNode(911); // 구조체 타입의 포인터 변수 MyNode에 반환된 NewNode의 주소값 저장
  ```
  다음 코드를 실행한다면, 노드생성을 성공하게될까?<br>
  답은 '아니다' 자동 메모리는 코드 블럭을 기준을 생성과 소멸이 일어난다. 즉, 코드 블럭 안에서 생성된 것들은 선언 당시에<br>
  자동 메모리에 저장되었다가 코드블럭의 끝에서 모두 자동으로 제거된다.<br>
  
  함수도 마찬가지이다. `SSL_CreateNode`함수 안에서 생성된 노드 `NewNode`는 선언 당시에 자동 메모리에 저장되었다가,<br>
  해당 함수가 종료되면서(코드 블럭의 끝) 모두 자동으로 제거되게 된다. <br>
  
  결국에 `SSL_CreateNode` 함수가 `NewNode`의 주소값을 반환하고 종료하게 되면, 해당 함수가 종료되면서, **자동 메모리 내에 저장되어 있던<br>
  `NewNode` 는 삭제되게 된다.**<br>
  그럼, 반환된 주소값은 `NewNode`가 존재했었던 주소값이 되는 것이다. 결국, 포인터 `MyNode`는 엉뚱한 메모리를 가리키게 된다.
  
  
    



