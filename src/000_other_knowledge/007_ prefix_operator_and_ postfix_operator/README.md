# 전위연산자와 후위연산자에 대한 확실한 이해

- ### 전위연산자
  ```c
  int a = 5;
  ++a;
  ```
  위 코드와 같이, **변수 앞에 증감연산자가 붙어있는 형태**이다.

- ### 후위연연산자
  ```c
  int a = 5;
  a++
  ```
  위 코드와 같이, **변수 뒤에 증감연산자가 붙어있는 형태**이다.<br>
  <br>

## 전위연산자와 후위연산자의 공통점과 차이점
- ### 공통점 - 변수에 단독적으로 사용한 경우
  `++a`, `a++` 과 같이, 변수 `a`에 대한 증감연산자를 단독으로 사용하는 경우, 전위연산자를 사용하든, 후위연산자를 사용하든<br>
  이 둘은 *'앞에 증감연산자가 표기되어 있냐'*, 아니면, *'뒤에 증감연산자가 표기되어 있냐'* 와 같은 보여지는 표기법 상 에서만<br>
  차이가 있을 뿐, `a = a + 1` 로, 동일하다.<br>

  ```c
  // 변수 a에 후위연산자를 단독적으로 사용한 경우
  int a = 5;

  a++;

  pritnf("a: %d\n", a);
  // a: 6
  ```

  ```c
  // 변수 a에 전위연산자를 단독적으로 사용한 경우
  int a = 5;

  ++a;

  printf("a: %d\n", a);
  // a: 6
  ```
  
  **`++a`** ▶ `a = a + 1, a = 6`<br>

  **`a++`** ▶ `a = a + 1, a = 6`<br>
  <br>

- ### 차이점 - 다른 값에 할당을 할 경우, 증감연산자의 위치에 따라 값이 달라진다.
  먼저, 예시코드를 보도록 하자.

  ```c
  // 전위연산자를 적용한 변수 a의 값을 다른 변수 b에 대입(할당)하는 경우
  int a = 5;
  int b = 0;

  b = ++a;

  printf("a: %d, b: %d \n", a, b);
  // a: 6, b: 6
  ```
  위 경우는 전위연산자를 적용한 변수 `a`의 값을 다른 변수 `b`에 대입하는 경우이다.<br>

  **`b = ++a;`**<br>
  
  위 코드에서 연산의 우선순위는 어떻게 될까?<br>
  그렇다. 먼저, 변수 `a`에 대한 증감연산을 먼저 하고(a = a + 1), 대입연산자(`=`)를 통해 해당 값이 변수 `b`에 대입될 것이다.<br>

  이렇게 전위연산자의 경우, 앞에 붙은 증감연산자를 통해, 증가/감소 된 값을 사용하여 해당 값을 다음 연산에 바로 사용한다.<br>
  먼저 계산하고, 계산된 값을 이용하여 다음 연산을 수행한다 라고 생각하면 편할 것이다.<br>

  때문에, 해당 예시코드의 결과로는 **`a: 6, b: 6`** 이 출력되게 된다.<br>

  ```c
  // 후위연산자를 적용한 변수 a의 값을 다른 변수 b에 대입(할당)하는 경우
  int a = 5;
  int b = 0;

  b = a++;

  printf("a: %d, b: %d \n", a, b);
  // a: 6, b: 5
  ```
  자, 이번 경우는 후위연산자를 적용한 변수 `a`의 값을 다른 변수 `b`에 대입하는 경우이다.<br>
  해당 예시코드의 결과와 전위연산자를 적용한 예시코드의 결과는 같을까? 다를까?<br>

  주석에도 나와있다시피, 다르다.<br>

  이번에 다뤄볼 후위연산자를 적용한 변수 `a`를 이용한 해당 예시코드의 결과로는 **`a: 6, b: 5`** 가 출력되게 된다.<br>
  왜 이러한 현상이 일어날까? 변수에 단독적으로 사용했을 때는 차이가 없지 않았나?<br>

  정답은 앞으로 설명할 후위연산자의 특성에 있다. 먼저, 다음 코드를 보도록 하자.<br>

  **`b = a++;`**<br>

  위 코드에서 연산의 우선순위는 어떻게 될까?<br>
  전위연산자의 경우와 같이, `a++`연산을 실행한 뒤, 그 다음에 변수 `b`로의 대입연산을 실행한다.<br>
  
  때문에, 실질적으로, 해당 시점에서 변수 `a`의 값이 늘어나게 되는 것은 맞지만, 그 다음에 있는 변수 `b` 로의<br>
  대입연산을 할 때에는 `a++`연산을 통해 증가되기 전의 값(5)를 따로 sava해 놓았다가 그 값을 사용한다.<br>
  
  때문에, 결과적으로, 변수`b`에는 `a++`을 통해 늘어난 6이 아닌, 따로 임시로 저장해 놓은 `a++`연산을 하기 전의<br>
  `a`의 값인 5가 대입되게 된다.<br><br>

  > **전위연산자의 경우, 증가된 값을 사용하여 해당 값을 다음 이어지는 연산에 바로 사용**하지만,<br>
  > **후위연산자의 경우, 우선 증가는 시키되, 증가 시키기 전의 값을 미리 따로 임시로 저장해 놓고,<br>
  > 그 값을 다음 연산에 사용**한다.<br><br>
  > 때문에, `b = a++` 의 경우, *'`b`에 `a`의 값(5)이 대입되고 나서 마지막에 `a++`연산이 실행된다!'* 라는<br>
  > 설명은 잘못된 설명이라 할 수 있다.<br>
  <br>

## while문을 통한 전위연산자, 후위 연산자의 이해
반복의 조건으로, 비교연산자와 전위/후위연산자를 함께 사용하는 `while`문에서는, 전위연산자를 사용하느냐,<br>
후위연산자를 사용하느냐에 따라, 반복 횟수가 달라진다.<br>

예들 들어, 다음 조건을 가진 `while`문이 있다고 하자.<br>

```c
int i = 0;

while(i++ <= 4) {
  ...
}
```
해당 `while`문의 조건, `i++ <= 4` 에서, 연산의 우선순위는, **1)** `i++ (후위연산)`, **2)** `<= 4 (비교연산)` 임을 명심하자!<br>

자, 이러한 연산의 우선순위를 기억하고, 다음 예시그림들을 보도록 하자.<br><br>
- ### while문과 전위연산자
  ![Slide14 - 복사본](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/3e05f803-7369-4e36-ab3c-66b43e09f31a)<br>
  다음 그림은 전위연산자를 이용한 `while`문의 동작과정을 나타낸 그림이다.<br>

  해당 그림을 보면 알 수 있듯이, 전위연산자의 경우, 전위연산을 실행한 뒤, 결과 값(전위연산을 통해 늘어난 값)을 바로<br>
  비교연산에 대입하여 조건이 되는 값, 4와 비교한다.<br>

  그렇기 때문에, 해당 `while`문을 실행하면, `1 2 3 4` 각 값을 4번 반복하여 출력하게 된다.<br>

  

- ### while문과 후위연산자
  ![Slide14](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/5d6b568b-feb7-4440-9b50-5b3afcfa8b48)<br>
  다음 그림은 후위연산자를 이용한 `while`문의 동작과정을 나타낸 그림이다.<br>

  해당 그림을 보면 알 수 있듯이, 후위연산자의 경우, 일단 후위연산을 실행하여 값을 증가 시킨뒤, 후위연산을 실행하기 전의<br>
  값을 따로 임시저장 해 놓은뒤, 해당 값을 비교연산에 대입하여 조건이 되는 값, 4와 비교한다.<br>

  즉, 첫 반복을 예로 들면, `num`의 초기 값인 0이 `while`문에 들어가면, 일단은 먼저 후위연산자 `num++`에 의해 우선은 값이<br>
  증가되어 1이 되지만, 후위 연산을 실행하여 값이 커지기 전의 값인 0을 따로 임시로 저장하게 된다.<br>

  그 다음 연산인 비교연산을 수행할때는 후위연산을 통해 증가된 값 1을 대입하는 것이 아니라, 따로 임시로 저장해 둔, 값이 증가<br>
  하기 전의 값을 대입한다.<br>

  **`후위연산을 통한 우선적인 값 증가`** ▶ **`해당 후위연산을 통해 값이 증가되기 전의 값을 따로 임시저장`** ▶<br>
   **`다음 연산에서는 증가된 값이 아닌 증가되기 전 임시저장해 둔 값 사용`**<br>

  이러한 이유로, 결국, 해당 `while`문을 실행하면, `1 2 3 4 5` 각 값을 5번 반복하여 출려하게 된다.<br>



  
  
