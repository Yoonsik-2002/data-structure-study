 # 추상자료형(Abstract Data Type)
> 구체적인 기능의 완성과정을 언급하지 않고, 순수하게 기능이 무엇인지를 나열한 것을 가리켜, 추상자료형 또는 ADT 라고한다.

- 예시) 지갑의 추상자료형
    - 카드의 삽입
    - 카드의 추출
    - 지폐의 삽입
    - 지폐의 추출

기능의 진행(완성)되는 과정을 언급하지 않고 기능이 무엇인지만 나열하였다. <br>
(`‘이런기능이 있고 이런 기능이 있어’` 기능의 명세!)<br>
<br>

### 자료형의 정의
완전한 자료형의 정의로 인식되기 위해서는 해당 자료형과 관련이 있는 연산이 함께 정의 되어야 한다.<br>
(c언어에서는 이러한 연산을 함수를 이용하여 정의한다.)

```c
Ex.1

// 구조체 기반 자료형 Wallet의 정의

typedef struct _Wallet
{
    int coin100Num;
    int bill5000Num;
} Wallet;

// Wallet을 기반으로 제공할 수 있는 기능 관련 연산의 정의

int TakeOutMoney(Wallet * pw, int coinNum, int billNum);     // 돈을 꺼내는 연산
void PutMoney(Wallet * pw, int coinNum, int billNum);    // 돈을 넣는 연산 
```
‘자료형’의 정의에 ‘기능’ 혹은 ‘연산’과 관련된 내용을 명시할 수 있다.  따라서 추상 자료형이라 하여 그것에 기능 또는<br>
연산과 관련된 내용을 명시할 수 없다는 생각은 버려야 한다.<br>
<br>

### Wallet의 추상 자료형(ADT)
- `int TakeOutMoney(Wallet * pw, int coinNum, int billNum);`
	 
    - 첫 번째 인자로 전달돤 주소의 지갑에서 돈을 꺼낸다.
    - 두 번째 인자로 꺼낼 동전의 수, 세 번째 인자로 꺼낼 지폐의 수를 전달한다.
    - 꺼내고자 하는 돈의 총액이 반환된다. 그리고 그만큼 돈은 차감된다.<br/><br/>
    
- `void PutMoney(Wallet * pw, int coinNum < int billNum);`
    - 첫 번째 인자로 전달된 주소이 지갑에 돈을 넣는다.
    - 두 번째 인자로 넣을 동전의 수, 세 번째 인자로 넣을 지폐의 수를 전달한다.
    - 넣은 만큼 동전과 지폐의 수가 증가한다.<br/><br/>
    
추상 자료형을 명시하는데 있어 명시해야 할 정보인 **기능**을 충분히 묘사하고 있다면 위와 같은 방법도 괜찮다.<br>
추상 자료형에 중요한 정보라면 무엇이든 추가할 수 있으며, 그 방법에는 제한이 없다. 하지만 불필요한 것을<br>
포함시키는 것은 바람직하지 못하다.<br>

코드 레벨 에서의 자료구조 구현 중심의 학습을 위해서는, 이 ADT를 어떻게 잘 정의하고, 이를 어떻게 일반화 시켜서<br>
자료구조를 정의하고 앞서 만든 자료구조를 뒤에서 잘 활용할 수 있을지에 초점을 두어서 공부해야 한다. <br>
<br><br>

# 리스트(List)
먼저, 리스트 자료구조를 학습하는데 있어, 다음 순서를 따라 학습해 나가려 한다.<br>

> 1. 리스트 자료구조의 ADT를 정의한다.<br>
> 2. ADT를 근거로 리스트 자료구조를 활용하는 `main` 함수를 정의한다.<br>
> 3. ADT를 근거로 리스트를 구현한다.<br>
<br>

### 리스트의 이해
*"리스트는 연결리스트를 의미하는 말인가?"* <br>

해당 질문에 대한 답은 '아니다' 라고 할 수 있다. 리스트(List) 라는 자료구조는 구현 방법에 따라 다음과 같이 크게 두 가지로 나눌 수 있다.<br> 

- #### 순차 리스트(Sequential List)
  배열을 기반으로 구현된 리스트<br>

- #### 연결 리스트(Linked List)
  메모리의 동적할당(`malloc` 함수를 통한 Heap 영역으로의 원하는 시점에서 자유로운 메모리 할당)을 기반으로 구현된 리스트<br>
<br>

이러한 두 리스트는 구현 방법에서의 차이에 따라 나눠진 것이기 때문에, 이 두 자료구조의 순수한 기능을 정의하는 ADT가 동일하더라도<br>
이는 문제가 되지 않는다.<br>

하지만, 또, 각 자료구조의 특성적 차이에 의한 ADT의 차이를 두기도 한다.<br>

결국, 해당 자료구조의 기본적인 특성에서 벗어나지 않는 선에서 필요에 따라 ADT에도 차이가 난다. 자료구조의 순수한 기능을 정의하는<br>
ADT라고 해서, 각종 자료구조들의 ADT는 무조건 표준이라 할 수 없다.<br>

이러한 리스트의 ADT를 정의하는데 있어 중요한, 리스트라는 자료구조의 기본적인 특성은 다음과 같다.<br>

**"데이터를 나란히 저장하고, 이러한 데이터들의 중복을 막지 않는다(허용한다)."** <br>
<br>

### 리스트의 ADT
**리스트의 ADT -** *'리스트라는 자료구조가 제공해야할 기능들은 무엇인가?'* 이를 나열한다.<br>

이때, 리스트라는 자료구조의 기본적이면서도 중요한 특성(데이터 나란히 저장, 중복 O)을 기반으로 제공해야할 기능들을 정의해야 한다!<br>
*'어떤 기능을 통해 리스트가 데이터를 나란히 저장하고, 중복을 허용하여 데이터들을 저장하게 할까?'* 이러한 접근이 중요!<br>
<br>

## 순차 리스트 (Sequential List)
순차 리스트란, 순차적인 메모리 공간을 할당하여 구현하는 리스트로, 보통 배열을 기반을 구현된다.<br>

- #### 순차 리스트의 장/단점
  | 장점 | 단점 | 
  |:-----|:-----|
  |정렬 기능을 사용하기 용이하다.|중간에 데이터를 삽입, 삭제하기 힘들다|
  |데이터를 특정 기준으로 관리하기 쉽다.|데이터를 삽입하고 삭제할 때마다, 데이터의 이동이 발생한다.|
  |인덱스(index)값을 통한 데이터 조회가 편리하다.|
<br>

이러한, 배열을 기반으로 구현되는 순차 리스트를 구조체를 이용하여, 코드로 나타내 보도록 하겠다.<br> 
```c
#define LIST_LEN 100;

typedef int LData;

typedef struct __ArrayList
{
  LData arr[LIST_LEN];
  int Num;
  int Current;
} ArrayList;

typedef ArrayList List;
```
<br>

다음 코드를 보면, 해당 구조체는 멤버변수로, 실질적인 데이터들을 저장하는 배열 `arr`과 해당 배열에 저장되어 있는 데이터의 개수를<br>
저장하는 `int`형 변수 `Num`, 배열의 현재 인덱스를 저장하는 `int`형 변수 `Current`로 이루어져 있는 것을 알 수 있다.<br>

이러한 순차 리스트 자료구조 모델을 그림으로 표현하면 다음과 같다.<br>

![sequential list](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/1d254584-1902-4f46-80eb-a8fe4afafe4f) <br>
<br>

이러한 형태를 띄는 순차 리스트의 ADT(순수한 기능)는 어떻게 될까?<br>
데이터를 나란히 저장하고, 이러한 데이터들의 중복을 허용하는 해당 자료구조의 기본적인 특성을 기반으로, 순차 리스트의 ADT를 한번 <br>
정의해 보도록 하겠다.<br>
<br>

### 순차 리스트의 ADT
앞으로 구현해 볼 순차 리스트의 ADT를 정의해 보도록 하겠다.<br>

이러한 ADT는 해당 자료구조를 구현할 프로그래밍 언어에 종속적으로 정의가 가능한데, 이러한 경우, 어떠한 프로그래밍 언어를 사용하느냐<br>
에 때라, 해당 ADT의 내용이 달라지기도 한다.<br>

먼저, C 라는 언어는 내가 변수를 생성한다고 해서, 자동으로 초기화 해주는 함수가 호출되지 않는다. 때문에, 초기화의 과정을 별도로 명령<br>
해야 한다. 즉, '초기화' 라는 기능(초기화를 담당하는 함수) 또한 ADT에 추가해야 한다는 것이다.<br>

반면, Java와 같은 객체지향 언어의 경우, '생성자' 라는 개념이 존재하여, 이러한 생성자를 통해 변수에 대응하는 인스턴스를 생성하면, 자동<br>
적으로 생성자 라는 함수가 호출되면서, 초기화의 기회를 자동적으로 제공받게 된다.<br>

때문에 이러한 객체지향 언어같은 경우, C언어와 같이, 초기화라는 기능을 별도로 ADT에 추가할 필요가 없어지게 된다.<br>

다음은 Java에서의 생성자에 의한 인스턴스의 자동적인 초기화를 다룬 예시 코드이다.<br>
```java
public class Car {
  String name;
  String price;

  public Car(String name, String price) {
    this.name = name;
    this.price = price;
  /*
  생성자는 해당 클래스의 인스턴스가 new 연산자를 통해 생성될 때,
  호출되어, 해당 인스턴스를 자동적으로 초기화 해주는 '인스턴스 초기화 메서드' 이다.
  */
  }
}
```

```java
public static void main(String[] args) {
  Car mercedes = new Car("E-Class", "88,000,000");
  // 인스턴스 생성과 동시에, 생성자를 통해, 해당 인스턴스에 대한 초기화의 기회가 자동적으로 주어짐.

  System.out.println("name : " + Car.name);
  System.out.pritnln("price : " + Car.price);
}
```
<br>

이러한, 프로그래밍 언어의 특성에 따른 차이점이 존재하기에, 프로그래밍 언어에 종속적인 ADT를 정의하는 경우, 같은 자료구조라도 해당<br>
ADT의 내용에선 차이가 생길 수 있다.<br>

일단, 나는 C언어를 이용하여 이 순차리스트 라는 자료구조의 ADT를 정의해 볼 것이기 때문에, 해당 ADT에는 초기화를 담당하는 함수에 대한<br>
내용을 해당 ADT에 추가할 것 이다.<br>
<br>

> - #### 기능 1) 순차 리스트의 생성 및 초기화<br>
>   **`void ListInit(List* pList);`**<br><br>
>   새로 생성한 구조체 변수 `list`의 주소값을 인자로 전달해 준다.<br>
>   리스트가 생성된 후, 가장 먼저 호출되어야 할 함수로, 생성된 리스트의 초기화를 담당한다.<br>
>   (위에서 설명하였듯이, C언어의 경우, 어떠한 변수가 생성되었다고 해서 이를 자동으로 초기화 해주지 않기 때문에, <br>
>   이러한 초기화를 담당하는 기능을 ADT에 명시하여야 한다.)<br><br>
> - #### 기능 2) 생성된 리스트에 데이터 저장<br>
>   **`void ListInsert(List* pList, LData data);`**<br><br>
>   데이터를 저장할 `list`의 주소값과, 저장할 데이터의 값을 인자로서, 매개변수 `pList`와 `data`에 각각 전달해 준다.<br>
>   결국, 데이터를 어디에(`list`) 저장하고, 어떠한 데이터를 저장할지에 대한 정보를 리스트에 데이터를 저장하는 함수인<br>
>   `ListInsert`에 전달하는 것이다.<br>
>   즉, 매개변수`pList`를 통해 주소값을 전달받은 리스트에 매개변수 `data`를 통해 전달받은 값을 저장한다.<br><br>
> - #### 기능 3) 저장된 데이터의 탐색 및 탐색 초기화<br>
>   순차적으로 나열되어 저장되어 있는 데이터를 탐색하는데 있어, 다시 처음부터(첫 번째 데이터 부터) 탐색을 하고 싶은 경우<br>
>   그 기준점이 되는 것이 바로, 첫 번째 데이터를 반환하는 아래의 `LFirst` 함수이다.<br>
>   첫 번째 데이터 이후의 데이터를 탐색하여 반환하고 싶은 경우, `LNext` 함수를 사용한다.<br>
>     - #### 기능 3-1) 저장된 데이터들 중, 첫 번째 데이터 반환<br>
>       **`int LFirst(List* pList, LData* pData);`**<br><br>
>       리스트에 저장되어 있는 데이터 중, 첫 번째 데이터를 탐색하여 `pData`가 가리키는 메모리에 저장한다.<br>
>       데이터의 참조를 위한 초기화가 진행된다.`*pData = pList -> arr[0];`<br>
>       참조 성공 시 `TRUE(1)`, 참조 실패 시 `FALSE(0)`를 반환한다.<br><br>
>       보통적으로 C언어 자료구조에서는 어떠한 함수를 통해서 반환받을 데이터를 저장할 메모리 공간을 할당한 다음,<br>
>       해당 메모리의 주소값을 인자로 전달한다.<br>
>       함수 `LFirst`의 경우도, 해당 함수를 통해 리턴되는 값을 반환받을 메모리의 주소값인 pData를 매개변수로 두어,<br>
>       반환할 리스트의 첫번째 데이터를 pData가 가리키고 있는 메모리에 저장하는 식으로 값을 반환한다.<br><br>
>     - #### 기능 3-2) 저장된 데이터들 중, 첫 번째 데이터의 다음 데이터들을 반환<br>
>       **`int LNext(List* pList, LData* pData);`**<br><br>
>       참조된 데이터의 다음 데이터가 pData가 가리키고 있는 메모리에 저장된다.      
>       순차적인 참조를 위해서, 반복 호출이 가능하다.<br>
>       참조를 새로 시작하기 위해선, `LFirst`함수를 먼저 호출해야 한다.<br><br>
> - #### 기능 4) 바로 이전에 반환이 이뤄진 데이터의 삭제<br>
>   **`LData LRemove(List* pList);`**
>   저장되어 있는 데이터를 반환하는 함수 `LFirst`나 <br>
>   `LNext`를 통해 마지막으로 반환된 데이터를 삭제한다.<br>
>   삭제된 데이터를 반환한다.<br><br>
> - #### 기능 5) 저장되어 있는 데이터의 수를 반환<br>
>   **`int LCount(List* pList);`**<br>
>   리스트에 저장되어 있는 데이터의 수를 반환한다.<br>







	




