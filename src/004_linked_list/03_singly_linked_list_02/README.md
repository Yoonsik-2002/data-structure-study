# 단순 연결 리스트(Singly Linked List)
연결의 형태가 한쪽 방향으로 전개되고, 시작과 끝이 분명히 존재하는 리스트 자료구조이다.<br>
<br>

## 📝 단순 연결 리스트의 ADT
이번에 공부해 볼 단순 연결 리스트의 ADT(기능)를 정리해 보도록 하겠다.<br>

**`void ListInit(List * plist);`**<br>
- 생성할 리스트의 초기화를 담당하는 기능이다.<br>
- 리스트 생성 후, 제일 먼저 호출해야 하는 기능이다.<br>
<br>

**`void LInsert(List * plist, LData data);`**<br>
- 리스트에 데이터를 저장한다. 매개변수 `data`에 전달된 값을 저장한다.<br>
<br>

**`int LFirtst(List * plist, Ldata * pdata);`**<br>
- 첫 번째 데이터가 `pdata`가 가리키고 있는 메모리에 저장된다.<br>
- 데이터의 참조를 위한 초기화가 이루어진다.<br>
- 참조 성공 시 `TRUE(1)`, 실패 시 `FALSE(0)`을 반환한다.<br>
<br>

**`int LNext(List * plist, Ldata * pdata);`**<br>
- 현재 참조되고 있는 데이터 다음으로 들어갈 데이터가 `pdata`가 가리키고 있는 메모리에 저장된다.<br>
- 순차적인 참조를 위해서 반복 호출이 가능하다.<br>
- 참조를 새로 시작하려면, 먼저 `LFirst`함수를 호출해야 한다. 데이터 탐색 및 참조의 기준은 항상 `LFist`함수이다.<br>
- 참조 성공 시 `TRUE(1)`, 실패 시, `FALSE(0)`을 반환한다.<br>
<br>

**`LData LRemove(List * plist);`**<br>
- `LFirst`혹은 `LNext`함수의 마지막 반환 데이터를 삭제한다.<br>
- 삭제된 데이터는 반환된다.<br>
- 마지막 반환 데이터를 삭제하므로 연이은 반복호출은 허용하지 않는다.<br>
<br>

**`int LCount(List * plist);`**<br>
- 리스트에 저장된 데이터의 개수를 반환한다.<br>
<br>

**`void SetSortRule(List * plist, int (*comp)(LData d1, LData d2);`**
- 리스트의 정렬의 기준이 되는 함수를 등록한다.<br>
<br><br>


## 새 노드의 추가 위치에 따른 장점과 단점 - 새 노드를 연결 리스트의 머리(head)에 추가하는 경우
### 장점 : 포인터 변수 `tail`이 불필요하다.<br>
- 새로운 노드를 꼬리에 추가하는 경우, 새로 추가하고자 하는 노드를 링크드 리스트의 마지막 노드에 연결하여 추가하는 것이기 때문<br>
  에, 이 마지막 노드를 가리키는 포인터 변수 `tail`이 필요하다.<br>
  
- 하지만, 이러한 포인터 변수 `tail`을 유지하기 위해서 넣어야할 부가적인 코드들이 번거롭게 느껴질 수 있으며, 리스트 자료구조는<br>
  저장된 순서를 유지해야 하는 자료구조가 아니다.<br><br>

### 단점 : 저장된 순서를 유지하지 않는다.<br>
- 새로운 노드를 링크들 리스트의 머리(head)에 추가하는 경우, 예를 들어, `1`, `2`, `3` 이라는 데이터를 저장한다고 할 때, 아래<br>
  와 같이, 데이터를 저장한 순서의 역순으로 저장이 된다.<br>

  `3` -> `2` -> `1` <br>
  > 첫 번째로 링크드 리스트의 머리에 저장된 값인 1을 다음에 저장된 2가 가리키고, 3이 2를 가리킴.<br>
  > 즉, 데이터가 저장된 순서를 유지하지 않는다.<br>

<br>

- 구현자 입장에서는, 저장된 데이터의 순서를 유지하는 것이 더욱 편할 수도 있지만, 위에서 말했다시피, 리스트 자료구조는<br>
  데이터가 저장된 순서를 유지해야 하는 자료구조가 아니다.<br>
<br>
  
이렇게, 새 노드를 연결리스트의 머리에 추가하는 경우, 데이터가 저장된 순서를 유지하지는 않지만, 포인터 변수 `tail`이 불필요하여,<br>
이와 관련된 부가적인 코드를 작성하지 않아도 된다는 장점이 있다.<br>

비교적 많은 자료구조 서적들도, 노드를 머리(head)에 추가하는 방식으로 연결리스트를 구현한다.<br>
<br><br>

## 연결 리스트의 정렬 기준을 지정하기 위한 함수 - `SetSortRule` (ft.함수 포인터)
이번 연결 리스트의 ADT를 작성하면서, 새롭게 추가한 리스트의 정렬 기준을 지정하기 위한 함수`SetSortRule`의 선언문<br>
은 아래와 같다.<br>
```c
void SetSortRule(List * plist, int (*comp)(LData d1, LData d2));
```
<br>

여기서 해당 함수의 두번째 매개변수인 `int (*comp)(LData d1, LData d2)`를 한번 봐 보자.<br>
이러한 문장의 형태는 함수의 주소값을 저장하는 함수 포인터의 선언 패턴으로, 이를 나누어서 해석해 보면 다음과 같다.<br>
<br>

![스크린샷(1)](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/5c96b66e-65ca-4634-a822-ac2e2889ae27)
<br>

먼저, `(*comp)`를 통해, `comp`라는 변수가 포인터 변수임을 선언해 주었다.<br>
그렇다면, 이 `comp`라는 포인터 변수는 무엇을 가리키는 포인터 변수일까?<br>

바로, `(*comp)`를 기준으로, 왼쪽에 있는 반환형 `int`와 오른쪽에 있는 매개변수 선언 `(LData d1, LData d2)`을 가지고 있는<br>
함수의 주소값을 저장할 수 있는 포인터 변수인 것이다.<br>

따라서, 해당 문장은 반환형이 `int`형이고, 매개변수에 `LData`형 인자 2개를 전달받는 함수의 주소값을 저장하는 포인터 변수<br>
`comp`의 선언문이라 할 수 있다.<br>
<br>

### `SetSortRule`함수를 통해서, 리스트에 적용하고자 하는 기능
`SetSortRule`함수는 연결 리스트의 정렬 기준을 지정하기 위한 함수이다.<br>

이번에 구현해볼 단순 연결 리스트는 리스트의 머리(head)에 노드를 추가하는 방식이므로, 리스트의 마지막 노드를 가리키는 포인터<br>
변수 `tail`에 관한 코드를 작성하지 않아도 된다는 장점이 있지만, 저장된 데이터(노드)의 순서(정렬순서)를 그대로 유지하지 못한다.<br>

그래서, 정렬의 기준을 나타내는 함수를 전달받아, 해당 정렬 기준을 연결 리스트에 적용시키는 `SetSortRule`함수를 추가하였다.<br>

즉, 어떤 정렬 기준을 나타내는 함수를 `SetSortRule`함수에 전달해 주었느냐에 따라, 코드를 수정하지 않고도, 해당 연결 리스트의<br>
정렬 기준이 바뀌는 것이다.<br>

이것이 가능한 이유는 "함수 포인터"가 가지는 의미가 이렇기 때문이다. 리스트 자료구조의 코드를 수정하지 않고도, 정렬 기준을<br>
나타내는 함수를 전달받음으로써 연결 리스트의 행동 패턴/내용이 달라질 수 있다.<br>

```c
void SetSortRule(List * plist, int (*comp)(LData d1, LData d2));
```
<br>

우리는 위 `SetSortRule`함수를 통해, 정렬기준을 리스트에 설치하여, 연결 리스트가 설치된 정렬기준에 맞게 동작하도록 만들 수<br>
있다.<br>

바로, `SetSortRule`의 두 번째 매개변수, 함수 포인터 `int (*comp)(LData d1, LData d2)`로의 정렬기준을 나타내는 함수의 전달을<br>
통해서 말이다!<br>

이때, 함수 포인터 변수 `comp`에 전달될 수 있는 함수의 조건은 다음과 같다.<br>
**반환형은 int형 이어야 하고, 매개변수에 인자로 전달되는 값은 `LData`타입의 변수 2개여야 한다.** <br>
<br>

### 정렬기준이 되는 함수의 정의
자, 그럼 한번 `SetSortRule`함수의 두번째 인자로 전달되는 함수를 한번 정의해 보도록 하겠다.<br>

`typedef int LData`, 노드의 저장되는 데이터의 값이 int형이라 가정하고, 해당 연결리스트의 노드가 저장하고<br>
있는 데이터 기준, 오름차순으로 정렬되도록 하는 함수, `WhoIsPrecede`이다.<br>

`WhoIsPrecede`함수를 정의하는데 있어, 제일 먼저 따져보아야 할 조건은 해당 함수의 반환형과 매개변수이다.<br>
그리고, 해당 함수가 반환하는 값이 어떤 의미를 갖는지는 연결리스트를 구현하는 본인이 결정할 문제이다.<br>

나는 `WhoIsPrecede`함수를 정의하는데 있어, 다음 조건을 갖춰 정의해야 하는 것으로 결정하였다.<br>

> 함수의 반환형은 int형이고, 매개변수는 `LData`타입의 변수, `d1`, `d2`이다. 그리고, 인자로 전달받은 `d1`값이<br>
> head에 더 가까워야 하는 경우에는 0을 반환하고, `d2`값이 head에 더 가까워야 하거나 같은 경우에는 1을 반환한다.<br>

<br>

이때, 구현하고자 하는 정렬기준이 '오름차순'이기에, 인자로 전달받은 `d1`, `d2` 값 중, 더 작은 값이 head에 가까워야 한다.<br>
이를 토대로 `WhoIsPrecede`함수를 구현해 보면 다음과 같다.<br>

```c
int WhoIsPrecede(LData d1, LData d2) {
  if(d1 < d2) // d1이 d2보다 더 작은 경우
    return 0; // d1이 head와 더 가깝다(앞선다).

  else // d2가 d1보다 더 작거나 같은 경우
    return 1; // d2가 head와 더 가깝거나 같다.
}
```
<br>

해당 함수에서는 `d1`이 `d2`보다 작아서 `d1`을 head와 더 가깝게 배치해야 하는 경우에는 `0`을 리턴하도록,<br>
`d2`가 `d1`보다 작아서 `d2`를 head와 더 가깝게 배치해야 하는 경우에는 `1`을 리턴하도록 리턴값의 의미를 지정해 주었다.<br>

**함수 포인터에 전달되는 함수의 반환값의 의미는 이를 구현하는 본인이 결정하는 것이다!** <br>

일단 이 점을 기억하고, `SetSortRule`함수가 어떻게 활용되고, 또 연결 리스트 내부적으로 어떠한 의미를 지니는지는<br>
해당 함수를 구현할 때 더욱 자세히 다뤄보도록 하겠다.<br>
<br><br>

## 일반적인 `head`와 `tail`기반의 단순 연결 리스트
이전까지 구현해 보았던 단순 연결리스트는 아래와 같은 구조를 지녔었다.<br>

![스크린샷(1)](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/73983a9b-cfdd-4fba-81d6-04f8046191a7)
<br>

[일반적인 `head`와 `tail`기반의 단순 연결 리스트](https://github.com/Yoonsik-2002/data-structure-study/blob/main/src/004_linked_list/02_singly_linked_list_01/LinkedRead.c)

이 경우, **"연결리스트의 첫 번째 노드는 포인터 변수 `head`가 가리켜야 한다"** 라는 하나의 제약사항이 생기게 된다.<br>

때문에, 코드 상에서 첫 번째 노드와 그 이후의 두 번째 노드 부터 나머지 노드의 처리 방식이 나뉘어지게 되어, 각가 탐색, 추가 ,삭제<br>
방식에 있어, 차이가 발생하게 된다.<br>

이때, 첫 번째 노드의 처리 방식이나, 그 이후의 두 번째 노드 부터 나머지 노드의 처리 방식이나 똑같이 일관된 방식을 사용하는 것이<br>
가장 바람직한 코드라고 할 수 있다.

하지만, 이렇게 `head`를 이용하여 첫 번째 노드와 그 이후의 노드를 구분짓는 구조에서는, 두 노드에 대해 일관적인 처리 방식을 적용<br>
하는 것이 불가능하다.<br>
<br><br>

## 더미 노드(Dummy Node) 기반의 단순 연결 리스트
이러한 문제점을 해결하기 위해, 아래와 같은 형태의 더미 노드 기반의 단순 연결 리스트를 만들어 보려 한다.<br>

![스크린샷(3)](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/a596b057-23bc-4fb4-834f-5a730fa15796)
<br>

[더미 노드(Dummy Node)를 추가한 `head`와 `tail`기반의 단순 연결 리스트](https://github.com/Yoonsik-2002/data-structure-study/blob/main/src/004_linked_list/03_singly_linked_list_02/LinkedReadUseDummyNode.c)

링크드 리스트의 노드를 앞에서 부터(`head`부터)추가하는 경우, 해당 링크드 리스트의 첫 번째 노드는 포인터 변수 `head`가 가리키게<br>
되고, 여기서 첫 번째 노드와 그 이후의 노드 간의 처리 방식의 일관성이 깨지게 된다.<br>

이때, 우리가 원하는 것은 유효한 데이터를 지닌 노드는 모두 처리 방식에 있어, 일관성을 띄도록 하는 것인데, 두 번째 노드부터<br>
나머지 노드의 경우에는 처리 방식이 일관되기 때문에, 유효한 데이터를 가지는 노드들은 두 번째 노드부터 나머지 노드여야 한다.<br>

이러한 점을 적용하여 연결 리스트를 구현하기 위해, 유효한 데이터를 지니지 않은 노드, 즉, 아무것도 아닌 깍뚜기 역할을 하는<br>
더미 노드(Dummy Node)를 리스트의 맨 앞에 미리 넣어 주었다.<br>

이렇게 빈 노드(Dummy Node)를 미리 넣어 둠으로써, 처음 추가되는 유효한 데이터를 지닌 노드는 구조상 두 번째 노드를 시작으로<br>
추가되게 되는 것이다! 이렇게 추가된 노드들은 추가, 삭제, 탐색 방식에 있어, 일관적인 처리 방식을 가지게 된다.<br>
<br><br>

## 정렬 기능이 추가된 연결 리스트의 구조체와 헤더 파일의 정의
연결 리스트의 구현에 있어, 필요한 구조체의 정의는 다음 두 가지가 있다.<br>

1. 연결 리스트를 구성하는 노드(Node)를 표현하는 구조체의 정의<br>
2. 연결 리스트를 의미하는 구조체의 정의<br>

<br>

### 1. 연결 리스트를 구성하는 노드(Node)를 표현하는 구조체의 정의
노드는 데이터를 저장하는 변수(메모리 공간)과 다음 노드의 주소값을 저장하여, 다음 노드와의 연결을 담당하는<br>
포인터 변수로 구성되어 있다.<br>

이를 구조체로 표현해 보면, 다음과 같다.<br>
```c
typedef struct _node {
  LData data;  // typedef int LData
  struct _node * next;
} Node;
```
<br>

### 2. 연결 리스트를 의미하는 구조체의 정의
이전에 구현하였던 [Linked Read.c](https://github.com/Yoonsik-2002/data-structure-study/blob/main/src/004_linked_list/02_singly_linked_list_01/LinkedRead.c)과 같은 프로그램에서는, 아래와 같은 연결 리스트와 관련된 변수들을 main함수의<br>
지역변수 혹은 전역변수로 선언하여 사용하였었다.<br> 

```c
Node * head;  // 연결 리스트의 첫 번째 노드를 가리키는 구조체 포인터 변수
Node * cur;  // 연결 리스트 내의 노드의 참조를 위한 구조체 포인터 변수
```
<br>

이때 만약, 프로그램 내에서 여러개의 리스트들을 사용하는 경우라면, 위와 같은 변수를 전역변수로, 혹은 main함수의 지역변수로 선언<br>
하여 사용할 경우, 각 리스트마다 해당 변수들을 각각 하나하나 따로 선언하여 사용해야하는 끔찍한 코드가 만들어진다.<br>

```c
#include <stdio.h>
Node * head1, *cur1;  // 첫 번째 연결 리스트를 위한 포인터 변수들
Node * head2, *cur2;  // 두 번째 연결 리스트를 위한 포인터 변수들
Node * head3, *cur3;  // 세 번째 연결 리스트를 위한 포인터 변수들

...

int main(void)
{
 ...
 return 0;
}
```
<br>

굳이 이렇게 프로그램 내에서 여러개의 리스트들을 사용하는 경우가 아니라도, 이러한 형태의 구현 방식은 프로그램의 구조를 좋지 못한<br>
형태로 이끄는 원인이 된다.<br>

따라서, `head`와 `cur`과 같이, 연결 리스트와 관련된 포인터 변수들을 묶어서 아래와 같이, 연결 리스트를 의미하는 구조체를 별도로 정의<br>
해 주는 것이 좋다.<br>

```c
typedef struct _linkedList {
  Node * head;  // 더미노드(Dummy Node)를 가리키는 멤버
  Node * cur;  // 참조 및 삭제를 돕는 멤버
  Node * before;  // 삭제를 돕는 멤버
  int numOfData;  // 저장된 데이터의 수를 기록하기 위한 멤버
  int (*comp)(LData d1, LData d2);  // 연결 리스트의 정렬기준을 등록하기 위한 멤버
} LinkedList;
```
<br>

연결 리스트를 생성하기 원한다면, 이 연결 리스트를 표현하는 구조체 `LinkedList`의 변수를 선언하거나 동적으로 할당하면 된다.<br>
<br><br>

## 더미 노드(Dummy Node) 기반의 단순 연결 리스트의 구현 
헤드 포인터가 가리키고 있는 연결 리스트의 첫 번째 노드를, 유효한 데이터가 저장되어 있지 않은 더미 노드로 가지고, 그 이후, 두 번<br>
째 노드 부터는 유효한 데이터를 가지는 노드를 저장하여, 유효한 데이터를 저장하는 노드끼리는 일관된 추가, 삭제, 탐색 방식을 적용<br>
하는 것이 가능한 더미 노드 연결 리스트를 만들어 보도록 하겠다.<br>

먼저, 해당 연결 리스트에 사용되는 구조체는 다음과 같다. <br>
##### 1. 노드를 표현하는 구조체 - `Node`
   ```c
   typedef struct _node {
     LData data;
     struct _node * next;
   } Node;
   ```
   
##### 2. 연결 리스트를 표현하는 구조체 - `LinkedList`
   ```c
   typedef struct _linkedList {
     Node * head;
     Node * cur;
     Node * before;
     int numOfData;
     int (*comp)(LData d1, LData d2);
   } LinkedList;

   typedef LinkedList List;

   // 연결 리스트를 생성하기 원한다면, `List`구조체의 변수를 선언하거나 동적으로 할당하면 된다.
   ```
<br>

### 생성할 리스트의 초기화
연결 리스트를 표현하는 구조체 `List`의 변수가 선언되어, 연결 리스트가 생성되면, 해당 리스트를 대상으로, 연결 리스트의 처리 작업<br>
을 위한, 기본적인 초기화가 이루어져야 한다.<br>

이러한 초기화 작업을 담당하는 함수는 아래와 같다.<br>

##### 리스트의 초기화 - ListInit 함수
```c
void ListInit(List * plist) {
  plist -> head = (*Node)malloc(sizeof(Node));  // 유효한 데이터를 저장하고 있지 않은 Dummy Node의 생성
  plist -> head -> next = NULL;
  plist -> comp = NULL;
  plist -> numOfdata = 0;
}
```
<br>

위의 초기화 결과를 그림으로 나타내 보면, 다음과 같다.<br>

![스크린샷(1)](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/eec0abb5-95d3-49b2-bd24-3469cc9fd23d)
<br>

유효한 데이터를 저장하고 있지 않은, Dummy Node를 연결 리스트의 첫 번째 노드로 추가하여, 연결 리스트의 첫 번째 노드를 가리키는 <br>
포인터 변수 `head`가 해당 Dummy Node를 가리키게 하였다.<br>

Dummy Node는 유효한 데이터를 저장하고 있지 않으므로, 연결 리스트의 데이터(노드)의 개수를 기록하는 변수인 `numOfData`는 0으로 <br>
초기화 된다.<br>

또, 연결 리스트가 막 생성된, 초기 시점에는 연결 리스트의 정렬 기준을 지정하는 함수가 함수 포인터 `comp`에 전달되지 않았기 때문에<br>
`comp`는 `NULL`을 저장하게 된다.<br>

이를 통해, 해당 Dummy Node 이후에 연결 리스트에 삽입되는 유효한 데이터를 지닌 노드들은 모두 일관된 처리방식을 통해 추가, 삭제<br>
탐색 작업이 이루어지게 된다.<br>
<br>

### 리스트에 노드 삽입(데이터 저장)
`ListInit`함수를 통해 생성한 연결 리스트에 노드를 삽입해 보도록 하겠다. 이때, 연결 리스트의 노드 삽입 시, 어떠한 방식으로 어떤<br>
기준을 가지고 노드를 삽입 하였느냐에 따라서, 연결 리스트에 저장되는 노드의 정렬 순서가 달라지게 된다.<br>

즉, `SetSortRule`함수의 매개변수 `comp`에 어떠한 정렬 기준을 나타내는 함수를 전달하였느냐에 따라 노드 삽입 방식이 달라지게 되<br>
고, 연결 리스트에 저장된 노드의 정렬 상태도 이에 따라 달라지게 되는 것이다.<br>
<br>

때문에, 이번에 만들고자 하는 연결 리스트의 경우, 노드 삽입 작업에 있어, 다음 두가지 경우의 수를 가지게 된다.<br>
1. 연결 리스트의 정렬 기준을 나타내는 함수가 `comp`에 전달되지 않은 경우 (= 연결 리스트의 정렬 기준이 정해지지 않은 경우)<br>
   `if(comp == NULL)`
   
2. 연결 리스트의 정렬 기준을 나타내는 함수가 `comp`에 전달된 경우 (= 연결 리스트의 정렬 기준이 정해진 경우)<br>
   `else`
<br>

따라서 리스트에 노드 삽입 작업을 담당하는 함수를 작성하는데 있어, 해당 두 가지의 경우를 적용하여 정의해 주어야 한다. 이러한 조<br>
건을 토대로, 리스트에 노드 삽입을 담당하는 함수 `LInsert`를 정의해 보면, 다음과 같은 구조를 띄게 될 것이다.<br>

##### 리스트에 노드 삽입 - LInsert 함수
```c
void LInsert(List * plist, LData data) {
  if(plist -> comp == NULL) { // 연결 리스트의 정렬 기준이 정해지지 않은 경우
    FInsert(plist , data); // 새로운 노드를 head에 추가(Dummy Node 바로 다음 노드로) 추가
  }
  else { // 연결 리스트의 정렬 기준이 정해진 경우
  SInsert(plist , data); // comp에 전달된 기준에 맞게 노드를 삽입하여 정렬
  }
```
<br>

이렇게, `List`의 노드 삽입 작업은 리스트의 멤버`comp`에 무엇이 저장되어 있느냐에 따라, `FInsert`함수 또는 `SInsert`함수를 통해서<br>
이루어진다.<br>

이때, `FInsert`함수와 `SInsert`함수는 헤더파일에 정의된 함수가 아니다. 이는, 해당 리스트를 사용하는 프로그래머는 이 두 함수를 직<br>
접 호출하여 사용하는 것이 불가능하다는 것을 의미한다. 이 함수들은 리스트 내부적으로 호출이 되도록 정의된 함수들이기 때문이다.<br>

다음은 연결 리스트의 정렬 기준이 정해지지 않은 경우, 즉 `plist -> comp == NULL`인 경우 `LInsert`함수 내부에서 호출되는 함수인<br>
`FInsert`함수이다. 새로운 노드를 생성하고, 이를 리스트의 머리(head), Dummy Node바로 다음 노드로 추가해준다.<br>
<br>

##### LInsert 함수 - case 1. 연결 리스트의 정렬 기준이 정해지지 않은 경우 : FInsert 함수
```c
void FInsert(List * plist, LData data) {
  newNode = (*Node)malloc(sizeof(Node)); // 새로운 노드의 생성
  newNode -> data = data;
  newNode -> next = plist -> head -> next; // 새로운 노드가 DummyNode 바로 다음 노드를 가리키게 함
  plist -> head -> next = newNode; // DummyNode가 새로운 노드를 가리키게 함
}
```
<br>

이렇게, `LInsert`함수에 인자로 전달된 `List`변수(연결 리스트)의 멤버인 `comp`가 `NULL`인 경우, 즉, 연결 리스트의 정렬 기준이 정해지지<br>
않은 경우, 위 `FInsert`함수가 호출되어, 새 노드가 연결 리스트의 머리(더미 노드 바로 다음)에 삽입되는 방식의 노드 삽입이 이루어진다.<br>

즉, 최근에 삽입된 노드일수록, 연결 리스트의 머리에 가까운 형태의 정렬상태를 가지게 되는 것이다. `LInsert`함수의 동작을 그림으로 나<br>
타내면 아래와 같다.<br>

![스크린샷(2)](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/101a6f05-e32f-41b6-a55d-cf62f382c9f4)
<br>










  

   




  





  




