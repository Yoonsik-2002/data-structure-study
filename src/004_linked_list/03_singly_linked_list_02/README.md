# 단순 연결 리스트(Singly Linked List)
연결의 형태가 한쪽 방향으로 전개되고, 시작과 끝이 분명히 존재하는 리스트 자료구조이다.<br>
<br>

## 📝 단순 연결 리스트의 ADT
이번에 공부해 볼 단순 연결 리스트의 ADT(기능)를 정리해 보도록 하겠다.<br>

**`void ListInit(List * plist);`**<br>
- 생성할 리스트의 초기화를 담당하는 기능이다.<br>
- 리스트 생성 후, 제일 먼저 호출해야 하는 기능이다.<br>
<br>

**`void LInsert(List * plist, LData data);`**<br>
- 리스트에 데이터를 저장한다. 매개변수 `data`에 전달된 값을 저장한다.<br>
<br>

**`int LFirtst(List * plist, Ldata * pdata);`**<br>
- 첫 번째 데이터가 `pdata`가 가리키고 있는 메모리에 저장된다.<br>
- 데이터의 참조를 위한 초기화가 이루어진다.<br>
- 참조 성공 시 `TRUE(1)`, 실패 시 `FALSE(0)`을 반환한다.<br>
<br>

**`int LNext(List * plist, Ldata * pdata);`**<br>
- 현재 참조되고 있는 데이터 다음으로 들어갈 데이터가 `pdata`가 가리키고 있는 메모리에 저장된다.<br>
- 순차적인 참조를 위해서 반복 호출이 가능하다.<br>
- 참조를 새로 시작하려면, 먼저 `LFirst`함수를 호출해야 한다. 데이터 탐색 및 참조의 기준은 항상 `LFist`함수이다.<br>
- 참조 성공 시 `TRUE(1)`, 실패 시, `FALSE(0)`을 반환한다.<br>
<br>

**`LData LRemove(List * plist);`**<br>
- `LFirst`혹은 `LNext`함수의 마지막 반환 데이터를 삭제한다.<br>
- 삭제된 데이터는 반환된다.<br>
- 마지막 반환 데이터를 삭제하므로 연이은 반복호출은 허용하지 않는다.<br>
<br>

**`int LCount(List * plist);`**<br>
- 리스트에 저장된 데이터의 개수를 반환한다.<br>
<br>

**`void SetSortRule(List * plist, int (*comp)(LData d1, LData d2);`**
- 리스트의 정렬의 기준이 되는 함수를 등록한다.<br>
<br><br>


## 새 노드의 추가 위치에 따른 장점과 단점 - 새 노드를 연결 리스트의 머리(head)에 추가하는 경우
### 장점 : 포인터 변수 `tail`이 불필요하다.<br>
- 새로운 노드를 꼬리에 추가하는 경우, 새로 추가하고자 하는 노드를 링크드 리스트의 마지막 노드에 연결하여 추가하는 것이기 때문<br>
  에, 이 마지막 노드를 가리키는 포인터 변수 `tail`이 필요하다.<br>
  
- 하지만, 이러한 포인터 변수 `tail`을 유지하기 위해서 넣어야할 부가적인 코드들이 번거롭게 느껴질 수 있으며, 리스트 자료구조는<br>
  저장된 순서를 유지해야 하는 자료구조가 아니다.<br><br>

### 단점 : 저장된 순서를 유지하지 않는다.<br>
- 새로운 노드를 링크들 리스트의 머리(head)에 추가하는 경우, 예를 들어, `1`, `2`, `3` 이라는 데이터를 저장한다고 할 때, 아래<br>
  와 같이, 데이터를 저장한 순서의 역순으로 저장이 된다.<br>

  `3` -> `2` -> `1` <br>
  > 첫 번째로 링크드 리스트의 머리에 저장된 값인 1을 다음에 저장된 2가 가리키고, 3이 2를 가리킴.<br>
  > 즉, 데이터가 저장된 순서를 유지하지 않는다.<br>

<br>

- 구현자 입장에서는, 저장된 데이터의 순서를 유지하는 것이 더욱 편할 수도 있지만, 위에서 말했다시피, 리스트 자료구조는<br>
  데이터가 저장된 순서를 유지해야 하는 자료구조가 아니다.<br>
<br>
  
이렇게, 새 노드를 연결리스트의 머리에 추가하는 경우, 데이터가 저장된 순서를 유지하지는 않지만, 포인터 변수 `tail`이 불필요하여,<br>
이와 관련된 부가적인 코드를 작성하지 않아도 된다는 장점이 있다.<br>

비교적 많은 자료구조 서적들도, 노드를 머리(head)에 추가하는 방식으로 연결리스트를 구현한다.<br>
<br><br>

## 연결 리스트의 정렬 기준을 지정하기 위한 함수 - `SetSortRule` (ft.함수 포인터)
이번 연결 리스트의 ADT를 작성하면서, 새롭게 추가한 리스트의 정렬 기준을 지정하기 위한 함수`SetSortRule`의 선언문<br>
은 아래와 같다.<br>
```c
void SetSortRule(List * plist, int (*comp)(LData d1, LData d2));
```
<br>

여기서 해당 함수의 두번째 매개변수인 `int (*comp)(LData d1, LData d2)`를 한번 봐 보자.<br>
이러한 문장의 형태는 함수의 주소값을 저장하는 함수 포인터의 선언 패턴으로, 이를 나누어서 해석해 보면 다음과 같다.<br>
<br>

![스크린샷(1)](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/5c96b66e-65ca-4634-a822-ac2e2889ae27)
<br>

먼저, `(*comp)`를 통해, `comp`라는 변수가 포인터 변수임을 선언해 주었다.<br>
그렇다면, 이 `comp`라는 포인터 변수는 무엇을 가리키는 포인터 변수일까?<br>

바로, `(*comp)`를 기준으로, 왼쪽에 있는 반환형 `int`와 오른쪽에 있는 매개변수 선언 `(LData d1, LData d2)`을 가지고 있는<br>
함수의 주소값을 저장할 수 있는 포인터 변수인 것이다.<br>

따라서, 해당 문장은 반환형이 `int`형이고, 매개변수에 `LData`형 인자 2개를 전달받는 함수의 주소값을 저장하는 포인터 변수<br>
`comp`의 선언문이라 할 수 있다.<br>
<br>

### `SetSortRule`함수를 통해서, 리스트에 적용하고자 하는 기능
`SetSortRule`함수는 연결 리스트의 정렬 기준을 지정하기 위한 함수이다.<br>

이번에 구현해볼 단순 연결 리스트는 리스트의 머리(head)에 노드를 추가하는 방식이므로, 리스트의 마지막 노드를 가리키는 포인터<br>
변수 `tail`에 관한 코드를 작성하지 않아도 된다는 장점이 있지만, 저장된 데이터(노드)의 순서(정렬순서)를 그대로 유지하지 못한다.<br>

그래서, 정렬의 기준을 나타내는 함수를 전달받아, 해당 정렬 기준을 연결 리스트에 적용시키는 `SetSortRule`함수를 추가하였다.<br>

즉, 어떤 정렬 기준을 나타내는 함수를 `SetSortRule`함수에 전달해 주었느냐에 따라, 코드를 수정하지 않고도, 해당 연결 리스트의<br>
정렬 기준이 바뀌는 것이다.<br>

이것이 가능한 이유는 "함수 포인터"가 가지는 의미가 이렇기 때문이다. 리스트 자료구조의 코드를 수정하지 않고도, 정렬 기준을<br>
나타내는 함수를 전달받음으로써 연결 리스트의 행동 패턴/내용이 달라질 수 있다.<br>

```c
void SetSortRule(List * plist, int (*comp)(LData d1, LData d2));
```
<br>

우리는 위 `SetSortRule`함수를 통해, 정렬기준을 리스트에 설치하여, 연결 리스트가 설치된 정렬기준에 맞게 동작하도록 만들 수<br>
있다.<br>

바로, `SetSortRule`의 두 번째 매개변수, 함수 포인터 `int (*comp)(LData d1, LData d2)`로의 정렬기준을 나타내는 함수의 전달을<br>
통해서 말이다!<br>

이때, 함수 포인터 변수 `comp`에 전달될 수 있는 함수의 조건은 다음과 같다.<br>
**반환형은 int형 이어야 하고, 매개변수에 인자로 전달되는 값은 `LData`타입의 변수 2개여야 한다.** <br>
<br>

### 정렬기준이 되는 함수의 정의
자, 그럼 한번 `SetSortRule`함수의 두번째 인자로 전달되는 함수를 한번 정의해 보도록 하겠다.<br>

`typedef int LData`, 노드의 저장되는 데이터의 값이 int형이라 가정하고, 해당 연결리스트의 노드가 저장하고<br>
있는 데이터 기준, 오름차순으로 정렬되도록 하는 함수, `WhoIsPrecede`이다.<br>

`WhoIsPrecede`함수를 정의하는데 있어, 제일 먼저 따져보아야 할 조건은 해당 함수의 반환형과 매개변수이다.<br>
그리고, 해당 함수가 반환하는 값이 어떤 의미를 갖는지는 연결리스트를 구현하는 본인이 결정할 문제이다.<br>

나는 `WhoIsPrecede`함수를 정의하는데 있어, 다음 조건을 갖춰 정의해야 하는 것으로 결정하였다.<br>

> 함수의 반환형은 int형이고, 매개변수는 `LData`타입의 변수, `d1`, `d2`이다. 그리고, 인자로 전달받은 `d1`값이<br>
> head에 더 가까워야 하는 경우에는 0을 반환하고, `d2`값이 head에 더 가까워야 하거나 같은 경우에는 1을 반환한다.<br>

<br>

이때, 구현하고자 하는 정렬기준이 '오름차순'이기에, 인자로 전달받은 `d1`, `d2` 값 중, 더 작은 값이 head에 가까워야 한다.<br>
이를 토대로 `WhoIsPrecede`함수를 구현해 보면 다음과 같다.<br>

```c
int WhoIsPrecede(LData d1, LData d2) {
  if(d1 < d2) // d1이 d2보다 더 작은 경우
    return 0; // d1이 head와 더 가깝다(앞선다).

  else // d2가 d1보다 더 작거나 같은 경우
    return 1; // d2가 head와 더 가깝거나 같다.
}
```
<br>

해당 함수에서는 `d1`이 `d2`보다 작아서 `d1`을 head와 더 가깝게 배치해야 하는 경우에는 `0`을 리턴하도록,<br>
`d2`가 `d1`보다 작아서 `d2`를 head와 더 가깝게 배치해야 하는 경우에는 `1`을 리턴하도록 리턴값의 의미를 지정해 주었다.<br>

**함수 포인터에 전달되는 함수의 반환값의 의미는 이를 구현하는 본인이 결정하는 것이다!** <br>

일단 이 점을 기억하고, `SetSortRule`함수가 어떻게 활용되고, 또 연결 리스트 내부적으로 어떠한 의미를 지니는지는<br>
해당 함수를 구현할 때 더욱 자세히 다뤄보도록 하겠다.<br>
<br><br>

## 일반적인 `head`와 `tail`기반의 단순 연결 리스트
이전까지 구현해 보았던 단순 연결리스트는 아래와 같은 구조를 지녔었다.<br>

![스크린샷(1)](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/73983a9b-cfdd-4fba-81d6-04f8046191a7)
<br>

[일반적인 `head`와 `tail`기반의 단순 연결 리스트](https://github.com/Yoonsik-2002/data-structure-study/blob/main/src/004_linked_list/02_singly_linked_list_01/LinkedRead.c)

이 경우, **"연결리스트의 첫 번째 노드는 포인터 변수 `head`가 가리켜야 한다"** 라는 하나의 제약사항이 생기게 된다.<br>

때문에, 코드 상에서 첫 번째 노드와 그 이후의 두 번째 노드 부터 나머지 노드의 처리 방식이 나뉘어지게 되어, 각가 탐색, 추가 ,삭제<br>
방식에 있어, 차이가 발생하게 된다.<br>

이때, 첫 번째 노드의 처리 방식이나, 그 이후의 두 번째 노드 부터 나머지 노드의 처리 방식이나 똑같이 일관된 방식을 사용하는 것이<br>
가장 바람직한 코드라고 할 수 있다.

하지만, 이렇게 `head`를 이용하여 첫 번째 노드와 그 이후의 노드를 구분짓는 구조에서는, 두 노드에 대해 일관적인 처리 방식을 적용<br>
하는 것이 불가능하다.<br>
<br><br>

## 더미 노드(Dummy Node) 기반의 단순 연결 리스트
이러한 문제점을 해결하기 위해, 아래와 같은 형태의 더미 노드 기반의 단순 연결 리스트를 만들어 보려 한다.<br>

![스크린샷(3)](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/a596b057-23bc-4fb4-834f-5a730fa15796)
<br>

[더미 노드(Dummy Node)를 추가한 `head`와 `tail`기반의 단순 연결 리스트](https://github.com/Yoonsik-2002/data-structure-study/blob/main/src/004_linked_list/03_singly_linked_list_02/LinkedReadUseDummyNode.c)

링크드 리스트의 노드를 앞에서 부터(`head`부터)추가하는 경우, 해당 링크드 리스트의 첫 번째 노드는 포인터 변수 `head`가 가리키게<br>
되고, 여기서 첫 번째 노드와 그 이후의 노드 간의 처리 방식의 일관성이 깨지게 된다.<br>

이때, 우리가 원하는 것은 유효한 데이터를 지닌 노드는 모두 처리 방식에 있어, 일관성을 띄도록 하는 것인데, 두 번째 노드부터<br>
나머지 노드의 경우에는 처리 방식이 일관되기 때문에, 유효한 데이터를 가지는 노드들은 두 번째 노드부터 나머지 노드여야 한다.<br>

이러한 점을 적용하여 연결 리스트를 구현하기 위해, 유효한 데이터를 지니지 않은 노드, 즉, 아무것도 아닌 깍뚜기 역할을 하는<br>
더미 노드(Dummy Node)를 리스트의 맨 앞에 미리 넣어 주었다.<br>

이렇게 빈 노드(Dummy Node)를 미리 넣어 둠으로써, 처음 추가되는 유효한 데이터를 지닌 노드는 구조상 두 번째 노드를 시작으로<br>
추가되게 되는 것이다! 이렇게 추가된 노드들은 추가, 삭제, 탐색 방식에 있어, 일관적인 처리 방식을 가지게 된다.<br>
<br><br>

## 정렬 기능이 추가된 연결 리스트의 구조체와 헤더 파일의 정의
연결 리스트의 구현에 있어, 필요한 구조체의 정의는 다음 두 가지가 있다.<br>

1. 연결 리스트를 구성하는 노드(Node)를 표현하는 구조체의 정의<br>
2. 연결 리스트를 의미하는 구조체의 정의<br>

<br>

### 1. 연결 리스트를 구성하는 노드(Node)를 표현하는 구조체의 정의
노드는 데이터를 저장하는 변수(메모리 공간)과 다음 노드의 주소값을 저장하여, 다음 노드와의 연결을 담당하는<br>
포인터 변수로 구성되어 있다.<br>

이를 구조체로 표현해 보면, 다음과 같다.<br>
```c
typedef struct _node {
  LData data;  // typedef int LData
  struct _node * next;
} Node;
```
<br>

### 2. 연결 리스트를 의미하는 구조체의 정의
이전에 구현하였던 [Linked Read.c](https://github.com/Yoonsik-2002/data-structure-study/blob/main/src/004_linked_list/02_singly_linked_list_01/LinkedRead.c)과 같은 프로그램에서는, 아래와 같은 연결 리스트와 관련된 변수들을 main함수의<br>
지역변수 혹은 전역변수로 선언하여 사용하였었다.<br> 

```c
Node * head;  // 연결 리스트의 첫 번째 노드를 가리키는 구조체 포인터 변수
Node * cur;  // 연결 리스트 내의 노드의 참조를 위한 구조체 포인터 변수
```
<br>

이때 만약, 프로그램 내에서 여러개의 리스트들을 사용하는 경우라면, 위와 같은 변수를 전역변수로, 혹은 main함수의 지역변수로 선언<br>
하여 사용할 경우, 각 리스트마다 해당 변수들을 각각 하나하나 따로 선언하여 사용해야하는 끔찍한 코드가 만들어진다.<br>

```c
#include <stdio.h>
Node * head1, *cur1;  // 첫 번째 연결 리스트를 위한 포인터 변수들
Node * head2, *cur2;  // 두 번째 연결 리스트를 위한 포인터 변수들
Node * head3, *cur3;  // 세 번째 연결 리스트를 위한 포인터 변수들

...

int main(void)
{
 ...
 return 0;
}
```
<br>

굳이 이렇게 프로그램 내에서 여러개의 리스트들을 사용하는 경우가 아니라도, 이러한 형태의 구현 방식은 프로그램의 구조를 좋지 못한<br>
형태로 이끄는 원인이 된다.<br>

따라서, `head`와 `cur`과 같이, 연결 리스트와 관련된 포인터 변수들을 묶어서 아래와 같이, 연결 리스트를 의미하는 구조체를 별도로 정의<br>
해 주는 것이 좋다.<br>

```c
typedef struct _linkedList {
  Node * head;  // 더미노드(Dummy Node)를 가리키는 멤버
  Node * cur;  // 참조 및 삭제를 돕는 멤버
  Node * before;  // 삭제를 돕는 멤버
  int numOfData;  // 저장된 데이터의 수를 기록하기 위한 멤버
  int (*comp)(LData d1, LData d2);  // 연결 리스트의 정렬기준을 등록하기 위한 멤버
} LinkedList;
```
<br>

연결 리스트를 생성하기 원한다면, 이 연결 리스트를 표현하는 구조체 `LinkedList`의 변수를 선언하거나 동적으로 할당하면 된다.<br>
완성된 더미 노드 기반의 단순 연결 리스트 프로그램의 헤더파일은 아래 링크를 클릭하면 볼 수 있다.<br>
[`DlilnkedList.h`](https://github.com/Yoonsik-2002/data-structure-study/blob/main/src/004_linked_list/03_singly_linked_list_02/dummy_node_based_singly_linked_list_program/DLinkedList.h)
<br><br>

## 더미 노드(Dummy Node) 기반의 단순 연결 리스트의 구현 
헤드 포인터가 가리키고 있는 연결 리스트의 첫 번째 노드를, 유효한 데이터가 저장되어 있지 않은 더미 노드로 가지고, 그 이후, 두 번<br>
째 노드 부터는 유효한 데이터를 가지는 노드를 저장하여, 유효한 데이터를 저장하는 노드끼리는 일관된 추가, 삭제, 탐색 방식을 적용<br>
하는 것이 가능한 더미 노드 연결 리스트를 만들어 보도록 하겠다.<br>

먼저, 해당 연결 리스트에 사용되는 구조체는 다음과 같다. <br>
##### 1. 노드를 표현하는 구조체 - `Node`
   ```c
   typedef struct _node {
     LData data;
     struct _node * next;
   } Node;
   ```
   
##### 2. 연결 리스트를 표현하는 구조체 - `LinkedList`
   ```c
   typedef struct _linkedList {
     Node * head;
     Node * cur;
     Node * before;
     int numOfData;
     int (*comp)(LData d1, LData d2);
   } LinkedList;

   typedef LinkedList List;

   // 연결 리스트를 생성하기 원한다면, `List`구조체의 변수를 선언하거나 동적으로 할당하면 된다.
   ```
<br>

### 생성할 리스트의 초기화
연결 리스트를 표현하는 구조체 `List`의 변수가 선언되어, 연결 리스트가 생성되면, 해당 리스트를 대상으로, 연결 리스트의 처리 작업<br>
을 위한, 기본적인 초기화가 이루어져야 한다.<br>

이러한 초기화 작업을 담당하는 함수는 아래와 같다.<br>

##### 리스트의 초기화 - ListInit 함수
```c
void ListInit(List * plist) {
  plist -> head = (*Node)malloc(sizeof(Node));  // 유효한 데이터를 저장하고 있지 않은 Dummy Node의 생성
  plist -> head -> next = NULL;
  plist -> comp = NULL;
  plist -> numOfdata = 0;
}
```
<br>

위의 초기화 결과를 그림으로 나타내 보면, 다음과 같다.<br>

![스크린샷(1)](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/eec0abb5-95d3-49b2-bd24-3469cc9fd23d)
<br>

유효한 데이터를 저장하고 있지 않은, Dummy Node를 연결 리스트의 첫 번째 노드로 추가하여, 연결 리스트의 첫 번째 노드를 가리키는 <br>
포인터 변수 `head`가 해당 Dummy Node를 가리키게 하였다.<br>

Dummy Node는 유효한 데이터를 저장하고 있지 않으므로, 연결 리스트의 데이터(노드)의 개수를 기록하는 변수인 `numOfData`는 0으로 <br>
초기화 된다.<br>

또, 연결 리스트가 막 생성된, 초기 시점에는 연결 리스트의 정렬 기준을 지정하는 함수가 함수 포인터 `comp`에 전달되지 않았기 때문에<br>
`comp`는 `NULL`을 저장하게 된다.<br>

이를 통해, 해당 Dummy Node 이후에 연결 리스트에 삽입되는 유효한 데이터를 지닌 노드들은 모두 일관된 처리방식을 통해 추가, 삭제<br>
탐색 작업이 이루어지게 된다.<br>
<br>

### 리스트에 노드 삽입(데이터 저장)
`ListInit`함수를 통해 생성한 연결 리스트에 노드를 삽입해 보도록 하겠다. 이때, 연결 리스트의 노드 삽입 시, 어떠한 방식으로 어떤<br>
기준을 가지고 노드를 삽입 하였느냐에 따라서, 연결 리스트에 저장되는 노드의 정렬 순서가 달라지게 된다.<br>

즉, `SetSortRule`함수의 매개변수 `comp`에 어떠한 정렬 기준을 나타내는 함수를 전달하였느냐에 따라 노드 삽입 방식이 달라지게 되<br>
고, 연결 리스트에 저장된 노드의 정렬 상태도 이에 따라 달라지게 되는 것이다.<br>
<br>

때문에, 이번에 만들고자 하는 연결 리스트의 경우, 노드 삽입 작업에 있어, 다음 두가지 경우의 수를 가지게 된다.<br>
1. 연결 리스트의 정렬 기준을 나타내는 함수가 `comp`에 전달되지 않은 경우 (= 연결 리스트의 정렬 기준이 정해지지 않은 경우)<br>
   `if(comp == NULL)`
   
2. 연결 리스트의 정렬 기준을 나타내는 함수가 `comp`에 전달된 경우 (= 연결 리스트의 정렬 기준이 정해진 경우)<br>
   `else`
<br>

따라서 리스트에 노드 삽입 작업을 담당하는 함수를 작성하는데 있어, 해당 두 가지의 경우를 적용하여 정의해 주어야 한다. 이러한 조<br>
건을 토대로, 리스트에 노드 삽입을 담당하는 함수 `LInsert`를 정의해 보면, 다음과 같은 구조를 띄게 될 것이다.<br>
<br>

##### 리스트에 노드 삽입 - LInsert 함수
```c
void LInsert(List * plist, LData data) {
  if(plist -> comp == NULL) { // 연결 리스트의 정렬 기준이 정해지지 않은 경우
    FInsert(plist , data); // 새로운 노드를 head에 추가(Dummy Node 바로 다음 노드로) 추가
  }
  else { // 연결 리스트의 정렬 기준이 정해진 경우
  SInsert(plist , data); // comp에 전달된 기준에 맞게 노드를 삽입하여 정렬
  }
}
```
<br>

이렇게, `List`의 노드 삽입 작업은 리스트의 멤버`comp`에 무엇이 저장되어 있느냐에 따라, `FInsert`함수 또는 `SInsert`함수를 통해서<br>
이루어진다.<br>

이때, `FInsert`함수와 `SInsert`함수는 헤더파일에 정의된 함수가 아니다. 이는, 해당 리스트를 사용하는 프로그래머는 이 두 함수를 직<br>
접 호출하여 사용하는 것이 불가능하다는 것을 의미한다. 이 함수들은 리스트 내부적으로 호출이 되도록 정의된 함수들이기 때문이다.<br>

다음은 연결 리스트의 정렬 기준이 정해지지 않은 경우, 즉 `plist -> comp == NULL`인 경우 `LInsert`함수 내부에서 호출되는 함수인<br>
`FInsert`함수이다. 새로운 노드를 생성하고, 이를 리스트의 머리(head), Dummy Node바로 다음 노드로 추가해준다.<br>
<br>

##### LInsert 함수 - case 1. 연결 리스트의 정렬 기준이 정해지지 않은 경우 : FInsert 함수
```c
void FInsert(List * plist, LData data) {
  newNode = (*Node)malloc(sizeof(Node)); // 새로운 노드의 생성
  newNode -> data = data;
  newNode -> next = plist -> head -> next; // 새로운 노드가 DummyNode 바로 다음 노드를 가리키게 함
  plist -> head -> next = newNode; // DummyNode가 새로운 노드를 가리키게 함
}
```
<br>

이렇게, `LInsert`함수에 인자로 전달된 `List`변수(연결 리스트)의 멤버인 `comp`가 `NULL`인 경우, 즉, 연결 리스트의 정렬 기준이 정해지지<br>
않은 경우, 위 `FInsert`함수가 호출되어, 새 노드가 연결 리스트의 머리(더미 노드 바로 다음)에 삽입되는 방식의 노드 삽입이 이루어진다.<br>

즉, 최근에 삽입된 노드일수록, 연결 리스트의 머리에 가까운 형태의 정렬상태를 가지게 되는 것이다. `LInsert`함수의 동작을 그림으로 나<br>
타내면 아래와 같다.<br><br>

![스크린샷(2)](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/101a6f05-e32f-41b6-a55d-cf62f382c9f4)
<br><br>

위 내용을 보면 알 수 있듯이, 연결 리스트의 `head`는 항상 `DummyNode`를 가리키고 있다. 새 연결 리스트가 생성될 때마다, `ListInit`함수를<br>
통해, `head`가 `DummyNode`를 가리키도록 초기화 되고, 유효한 데이터를 지닌 모든 노드들은 Dummy Node 다음 노드로 삽입되기 때문이다.<br>

때문에, 새 노드를 생성하고, 연결 리스트에 삽입해주는 `FInsert`함수에는 `if ... else`문이 존재하지 않는다. 이는 어떠한 조건을 따지지 <br>
않고, 유효한 데이터를 지닌 모든 노드의 추가과정이 일관되게 정의되어 있음을 의미한다.<br>

더미 노드 기반의 연결 리스트를 사용하면, "유효한 데이터를 저장하고 있는 모든 노드의 삽입, 삭제의 처리 방식을 일관되게 정의하는 것이 <br>
가능하다."<br>
<br>

### 리스트에 저장된 데이터의 탐색 및 조회
리스트에 저장된 데이터의 탐색 및 조회를 담당하는 함수의 경우, 다음 두가지 역할을 담당하는 함수로 나뉘게 된다.<br>
1. 첫 번째 데이터를 조회하는 `LFirst`함수
2. 두 번째 데이터 부터, 그 이후의 데이터를 조회하는 `LNext`함수

이전에도 언급하였듯이, 연결 리스트의 첫 번째 데이터를 조회하는 함수와, 두 번째 데이터 부터, 그 이후의 데이터들을 조회하는 함수를 나누어 <br>
정의해준 이유는 첫 번째 데이터를 탐색하는 **탐색의 시작점**을 구분해 주기 위함이다.<br>

연결 리스트의 데이터를 탐색하는데 있어, 다시 첫 번째 데이터부터 탐색을 진행하고자 하는 경우, 이 첫 번째 데이터의 탐색을 나타내는 하나의<br>
기준이 되어주는 것이 바로, `LFirst`함수가 되는 것이다.<br>

이때, 우리가 현재 만들고 있는 연결 리스트는, 첫 번째 노드의 추가, 삭제, 탐색 작업과 두 번째 노드와 그 이후 노드들의 추가, 삭제, 탐색 작업을<br>
일관된 방식으로 구현하는 것이 가능한 DummyNode 기반의 연결리스트이다.<br>

따라서, `LFirst`함수와 `LNext`함수를 따로 정의한 이유는, 다시 첫 번째 데이터부터 조회하고자 할 때, 조회의 시작점이라는 하나의 기준을 만들<br>
어주기 위함일 뿐이지, **두 함수의 데이터 탐색 및 조회 작업의 구현에 있어서는 일관된 방식을 통한 구현이 가능하다.**<br>
<br>

##### 첫 번째 데이터의 탐색 및 조회 - LFirst 함수
```c
int LFirst(List * plist, LData * pdata) {
  if(plist -> head -> next == NULL) // Dummy Node 다음 노드가 존재하지 않는다면, FALSE를 리턴하고 종료
    reutrn FALSE;

  plist -> before = plist -> head; // 구조체 포인터 before는 DummyNode를 가리키게함
  plist -> cur = plist -> head -> next; // 구조체 포인터 cur는 유효한 데이터를 저장하고 있는 첫 번째 노드를 가리키게 함

  *pdata = plist -> cur -> data; // 함수 외부에 정의되어 있는 int형 변수 data에 포인터 *pdata를 통해 첫 번째 노드의 데이터를 반환

  return TRUE; // 연결 리스트의 첫 번째 데이터의 탐색 및 조회에 성공. TRUE를 반환
}
```
<br>

해당 연결 리스트의 데이터의 탐색 및 조회 작업에는 위 코드를 보면 알 수 있듯이, 구조체 포인터 `before`과 `cur`가 사용된다. `before`가 `cur`이<br>
가리키고 있는 노드보다 앞선 노드를 가리키는 방식으로 작동한다.<br>
<br>

이 `First`함수에서는 이와 같은 작동방식을 구현해낸 아래 코드가 핵심이라 할 수 있다. 이러한 처리 방식은 `LNext`에서도 일관되게 사용된다.<br>
```c
plist -> before = plist -> head; // 구조체 포인터 before가 DummyNode를 가리킴
plist -> cur = plist -> head -> next; // 구조체 포인터 cur이 유효한 데이터를 저장하고 있는 첫 번째 노드(DummyNode 다음 노드)를 가리킴
```
<br>

`LFirst`함수의 동작과정을 그림으로 나타내면 아래와 같다.<br>
<br>

![스크린샷(2)](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/aba8b3f1-f932-482a-95a1-4f86cf7302e5)


<br><br>

##### 두 번째 데이터와 그 이후 데이터들의 탐색 및 조회 - LNext 함수
```c
int LNext(List * plist , LData * pdata) {
  if(plist -> cur -> next == NULL) // 현재 노드를 가리키는 cur의 다음 노드가 존재하지 않는 경우, FALSE를 리턴하고 종료
    return FALSE;

  plist -> before = plist -> cur; // before가 기존에 cur이 가리키고 있던 노드를 가리키게 함 
  plist -> cur = plist -> before -> next; // cur은 (before가 가리키고 있는 노드의) 그 다음 노드를 가리키게 함

  *pdata = plist -> cur -> data; // 함수 외부에 정의되어 있는 int형 변수 data에 포인터 *pdata를 통해 첫 번째 노드의 데이터를 반환
  return TRUE; // 연결 리스트의 데이터의 탐색 및 조회에 성공. TRUE를 반환
}
```
<br>

해당 함수를 보면, 구조체 포인터 기본적으로 `before`는 구조체 포인터 `cur`의 바로 이전 노드를 가리키며, 다음 노드를 탐색하게 될 때 마다,<br>
`before` 가 현재 `cur`이 가리키고 있는 노드를 가리키고, `cur`은 `before`가 가리키고 있는 노드의 다음 노드를 가리키는 방식으로 노드를 하<br>
나씩 오른쪽으로 옮겨가며 탐색 한다는 것을 알 수 있다.<br>
<br>

때문에, 위의 `LNext`함수의 핵심코드 또한 아래와 같은 처리방식을 띄며, 이는 `LFirst`의 핵심 코드와 똑같은(일관된)형태를 가진다는 것을 알<br>
수 있다.<br>
```c
plist -> before = plist -> cur; // 구조체 포인터 before가 기존에 cur이 가리키고 있던 노드를 가리킴
plist -> cur = plist -> before -> next; // cur은 그 다음 노드(plist -> before -> next)를 가리킴
```
<br>

해당 `LNext`함수를 반복하여 호출 시, `plist -> cur`이 `NULL`을 가리킬 때 까지(`plist -> cur -> next == NULL`) 즉, 마지막 `cur`이 마지막 노드<br>
를 가리킬 때 까지 데이터를 탐색 및 조회하고, 종료하게 된다. 연결 리스트의 유효한 데이터를 지닌, 첫 노드 이후 모든 노드를 조회하고 종료되
는 것이다.<br>

`LNext`함수의 동작과정을 그림으로 나타내면 다음과 같다.<br>
```



// ppt 그림 추가



```
<br><br>

### 리스트에 저장되어 있는 노드(데이터)의 삭제
노드의 삭제 작업을 담당하는 `LRemove`함수는 아래와 같이 동작한다.<br>
> 삭제하고자 하는 노드를 `LFirst`함수나 `LNext`함수를 통해 탐색 및 조회하고, 바로 이전에 `LFirst`함수나 `LNext`함수가 반환한 데이터(해<br>
당 데이터를 저장하고 있는 노드)를 삭제한다.

<br>

아래 그림과 같은 상황에서 `LRemove`함수가 호출되었다고 해보자.<br>
```



// ppt 그림 추가



```
<br>

해당 상황은 `LNext`함수를 통해 4가 반환되었다는 뜻이다. 따라서, `LRemove`함수를 통해서, 4라는 데이터를 저장하고 있는, 현재 `cur`이 가리키<br>
고 있는 노드를 소멸 시켜주어야 한다.<br>
<br>

해당 노드가 연결 리스트에서 삭제되는 과정은 다음 그림과 같다.<br>
```



// ppt 그림 추가



```
<br>

이때, `plist -> cur = plist -> before;` 코드를 보고, *'`cur`은 `before`가 참조하고 있는 노드의 다음 노드를 가리켜야 하는거 아닌가?'* 라는 생<br>
각이 들 수 있다. 하지만, 그렇다고 해서 `cur`이 6을 저장하는 노드를 가리키게 하면, **해당 노드까지 탐색이 이루어졌다는 뜻이 되어버린다.** <br>

아직 6을 저장하고 있는 노드까지 탐색이 이루어지지 않았기 때문에, `cur`을 한칸 왼쪽으로, `before`이 가리키고 있는 노드로 이동시켜 주어야<br>
한다. 어차피 다시 `LFirst` 또는 `LNext`함수를 호출하면 `before`는 다시 `cur`보다 한 칸 앞선 노드를 가리키게 된다.<br>
<br>

##### 노드의 삭제(소멸) 및 삭제된 데이터의 반환 - LRemove 함수
```c
LData LRemove (List * plist, LData * pdata) {
  List * rpos = plist -> cur;
  LData rdata = rpos -> data;

  plist -> before -> next = plist -> cur -> next;
  plist -> cur = plist -> before;

  free(rpos);
  (plist -> numOfData)--;
  *pdata = rdata;
}
```
<br>

이때, 왜 굳이 구조체 포인터 `rpos`와 변수 `rdata`를 따로 생성하여 삭제하고자 하는 노드의 주소값과 데이터를 저장할까? 해당 질문에 대한 답<br>
은 아래 코드에 있다. `LRemove`함수에서 핵심적인 역할을 하는 코드이다.<br>
```c
plist -> before = plist -> cur -> next;
plist -> cur = plist -> before;
```
<br>

해당 코드가 실행되면, 삭제하고자 하는 노드를 자신의 다음 노드(`next`)로서 가리키는 노드가 사라지고, `cur`과 `before`또한 해당 노드를 가리<br>
키지 않는 상태가 된다. 즉, 쉽게 말해 노드와 구조체 포인터 `cur`과 `before`모두 해당 노드를 가리키고 있지 않은 상태가 되는 것이다.<br>

이러한 상태에서는 삭제하고자 하는 노드의 주소값을 `free`함수에 전달하여 heap영역에서 완전히 소멸시킬 수도, 삭제한 노드의 데이터를 반환<br>
해줄 수도 없다.<br>

때문에, 해당 코드를 실행하기 전에, 삭제하고자 하는 노드의 주소값과 저장하고 있는 데이터를 사전에 미리 다른 변수를 생성하여 저장해 두어<br>
야 한다.<br>

이때, 노드의 주소값(`List * rpos`)과 노드가 저장하고 있는 데이터(`Ldata rdata`)를 각각 다른 변수에 따로 저장해둔 이유는 `free(rpos)`를 호<br>
출해 버리면 `rpos`가 완전히 메모리 공간에서 소멸되어, 해당 노드가 저장하고 있는 데이터를 반환하지 못하게 되기 때문이다.<br>
<br>

다음은 `LRemove`함수가 삭제하고자 하는 노드를 연결리스트에서 삭제하고, heap 메모리에서 완전히 소멸시키는 과정을 나타낸 그림이다.<br>
```



// ppt 그림 추가



```
<br>

### 연결 리스트의 정렬기준 삽입의 구현
자, 이제 연결 리스트의 마지막 기능의 구현이 남았다. 해당 연결 리스트의 마지막 기능으로, 프로그래머가 직접 리스트의 정렬기준을 설정할 수 있도록, 정렬의 기준이 되는 함수를 리스트에 등록하여(정렬기준의 설정) 리스트의 정렬이 이루어질 수 있도록 ADT를 정의하였었는데,<br>

이제, 해당 기능을 구현해 보도록 하겠다.<br>
<br>

##### 구현할 연결 리스트에서 정렬기준의 설정과 관련된 부분
지금 구현하고 있는 연결 리스트에서 정렬기준의 설정과 관련된 부분은 다음과 같다. 이들을 하나로 묶어서 생각하면 이해가 쉽다.<br>

- 연결 리스트의 정렬 기준이 되는 함수를 등록하는 **`SetSortRule`** 함수<br>
  ``` c
  void SetSortRule(List * plist , int (*comp)(LData d1, LData d2));
  ```
<br>

- `SetSortRule`함수를 통해서 정렬 기준이 되는 함수를 저장하는(가리키는) 함수 포인터 **`comp`**, 연결 리스트를 표현하는 구조체 `LinkedList`의 멤버이다.<br>
  ``` c
  typedef struct _linkedList {
    Node * head;
    Node * cur;
    Node * before;
    int numOfData;
    int (*comp)(LData d1, LData d2);
  } LinkedList;

  // SetSortRule 함수룰 통해, 정렬 기준이 되는 함수가 LinkedList 구조체의 멤버인comp에 저장됨
  ```
<br>

- `comp`에 저장되어 있는 정렬 기준이 되는 함수를 근거로, 데이터를 저장(삽입)하는 **`SInsert`** 함수. 어떠한 기준으로 데이터의 삽입이 이루어졌느냐에 따라, 데이터의 정렬상태가 달라지는 것이다. 해당 함수는 `comp`가 NULL이 아닐 시, `LInsert`함수 내부에서 호출되어 작동한다.<br>
  ```c
  void LInsert(List * plist, LData data) {
    if(plist -> comp == Null) {
      FInsert(plist, data);
    }
    else {
      SInsert(plist, data);
    }
  }
  ```
<br>

위 세 부분을 하나의 문장으로 정리해 보면, 다음과 같다.<br>

*"`SetSortRule` 함수가 호출되면서, 연결 리스트의 정렬의 기준이되는 함수가 리스트 구조체 멤버인 함수 포인터 `comp`에 등록되면, `LInsert`함수에서는 내부적으로 `SInsert`함수를 호출하여, `comp`에 등록된 함수를 근거로 데이터를 삽입하여 정렬해 나간다."*<br>

연결 리스트의 정렬 기준 설정과 관련된 부분이 무엇이 있는지 정리해 보았으니, 이제 `SetSortRule`함수와 `SInsert`함수를 마저 완성해 보도록 하겠다.<br>
<br>

##### 연결 리스트의 정렬기준이되는 함수의 등록 - `SetSortRule` 함수
`SetSortRule`함수는 연결 리스트의 정렬기준이 되는 함수를 함수 포인터 타입의 매개변수 `comp`에 전달 받고, 해당 값을 링크드 리스트를 표현하는 구조체 `List`의 멤버인 `comp`에 저장시킴으로써 연결 리스트의 정렬 기준이 되는 함수를 등록해준다.<br>
<br>

이를 간단히 요약하면 `SetSortRule`함수는 `List`의 멤버변수 `comp`를 초기화 하는 함수라 할 수 있다. `SetSortRule`함수를 구현해 보면 다음과 같다.<br>
```c
void SetSortRule(List * plist, int (*comp)(LData d1, LData d2)) {
  plist -> comp = comp;
}
```
<br>

함수 포인터 매개변수 `comp`에 전달된 정렬 기준이 되는 함수의 주소값을 `List`의 멤버인 `comp`에 저장시키는 것으로, 해당 함수를 호출하면, 정렬 기준이 되는 함수가 연결 리스트에 등록되게 된다. 이렇게 등록된 정렬 기준을 토대로 데이터를 삽입하여 정렬하는 것이다!<br>
<br>

##### 정렬 기준이 리스트에 등록되어 있는 경우(`plist -> comp != NULL`), 해당 정렬 기준을 토대로 데이터를 삽입하여 정렬하는 함수 - `SInsert` 함수
`SInsert`함수의 작동과정을 그림과 함께 이해해 보도록 하겠다. 먼저, 아래와 같이 오름차순으로 정렬되어 있는 연결 리스트가 존재한다고 해보자. 해당 연결 리스트의 이름은 `slist`이다.<br>
<br>

![스크린샷(2)](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/92a5b74b-1e08-4436-9081-d012fd39556b).<br>
<br>

이 상태에서, 아래와 같이 `SInsert`함수의 호출이 이루어 졌다고 해보자.<br>
```c
SInsert(&slist, 5); // 리스트에 데이터5를 지닌 노드를 추가
```
<br>

그러면, 새 노드를 생성하여 추가하는 `LInsert`함수의 내부에서 호출되어 작동하는 `SInsert`함수에서는, 다음과 같이 새 노드를 생성하고, 노드를 추가하는데 사용되는 구조체 포인터 변수 `pred`를 초기화 하고, 새로 생성된 노드에 데이터를 저장하는 작업이 먼저 이루어져야 할 것이다.<br>
```c
void SetSortRule(List * plist, LData data) {
  Node * newNode = (Node*)malloc(sizeof(Node)); // 새 노드 생성
  Node * pred = plist -> head; // pred는 더미 노드를 가리킴
  newNode -> data = data; // 새 노드의 data에 5 저장
  // ...
}
```
<br>

해당 작업이 모두 이루어지고 나면, 아래와 같은 상태가 될 것이다.<br>
<br>

![스크린샷(3)](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/a0056408-0f24-4b37-900b-62994a082695)<br>
<br>

이때, `pred`가 dummy node부터 가리키는 이유는 무엇이며, `pred`의 기능은 무엇일까? `comp`에 정렬 기준이 되는 함수가 등록되지 않아, `FInsert`함수를 통해 새 노드를 삽입하는 경우엔 무조건 연결리스트의 head(dummy node)에 새 노드를 추가해주면 되었었다.<br>

하지만, `comp`에 정렬 기준이 되는 함수가 등록되어, 이를 토대로 연결 리스트에 새 노드를 추가해야하는, `SInsert`함수를 통해 새 노드를 삽입하는 경우는 다르다.<br> 

`FInsert`함수를 사용했을 때 처럼 무조건 연결 리스트의 head가 아닌, **정렬 조건에 부합하는 알맞은 위치에 새 노드가 추가되어야 한다.** 이때, 우리는 구조체 포인터 변수 `pred`를 활용하여 노드를 추가한다.<br>

그렇다면, `pred`가 유효한 데이터를 지닌 2를 저장하는 첫 번째 노드부터 가리키지 않고, dummy node부터 가리키는 이유는 무엇일까? 해당 질문에 대한 답은 연결리스트의 연결이 형성되어 있는 방향에 있다.<br>

그림을 보면 알 수 있듯이, 연결 리스트의 연결 방향은 오르쪽으로 형성되어 있다. 때문에, 노드의 추가에도 해당 연결 방향이 적용되어, **`pred`가 가리키는 노드의 오른쪽에 새 노드를 추가하는 것 만이 가능**하고, 왼쪽에는 새 노드를 추가하는 것이 불가능 하다.<br>

예를 들어, 오름차순으로 정렬이 이루어져야 하는 `slist`에 데이터 1을 저장하고 있는 새 노드를 추가해야한다고 해 보자. 이때, `pred`가 아래 그림과 같이 첫 번째 노드인 2를 가리키고 있는 경우, 해당 노드의 왼쪽에 새 노드를 추가해 주어야 한다. 하지만 이는 불가능하다.<br>
<br>

![스크린샷(7)](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/706345e8-40eb-44be-b912-922afb200ec6)<br>
```c
newNode -> next = pred;
pred -> next = ?? ... // pred가 가리키는 노드의 왼쪽에 새 노드를 추가하는 것은 불가능함.
```
<br>

반면, `pred`가 dummy node부터 가리키고 있는 경우엔, dummy node의 오른쪽에 새 노드를 추가하게 되어, 우리가 원하는 위치인 2를 저장하고 있는 노드의 왼쪽에 새 노드를 추가하는 것이 가능하다.<br>
<br>

![스크린샷(5)](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/370d2b5d-59ae-4430-8636-fa7fcf818997)<br>
```c
newNode -> next = pred -> next;
```
<br>

![스크린샷(6)](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/526b0a0a-a294-4927-92b2-2e928778842c)<br>
```c
pred -> next = newNode;
```
<br>

이렇게, 위 예시에서의 2를 저장하고 있는 노드와 같이, 유효한 데이터를 저장하고 있는 첫 번째 노드의 왼쪽(바로 이전에) 새 노드를 추가해야 하는 경우가 생길 수도 있으므로, `pred`는 dummy node 부터 가리켜야 한다.<br>

오른쪽으로 연결이 형성되어 있는 연결 리스트 특성상, `pred`를 활용하여 새 노드를 추가하는 `SInsert`함수에서, **`pred`기준, 오른쪽에 새 노드를 추가하는 것만이 가능하기 때문이다.** <br>










