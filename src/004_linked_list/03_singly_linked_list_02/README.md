# 단순 연결 리스트(Singly Linked List)
연결의 형태가 한쪽 방향으로 전개되고, 시작과 끝이 분명히 존재하는 리스트 자료구조이다.<br>
<br>

## 📝 단순 연결 리스트의 ADT
이번에 공부해 볼 단순 연결 리스트의 ADT를 정리해 보도록 하겠다.<br>

**`void ListInit(List * plist);`**<br>
- 생성할 리스트의 초기화를 담당하는 기능이다.<br>
- 리스트 생성 후, 제일 먼저 호출해야 하는 기능이다.<br>
<br>

**`void LInsert(List * plist, LData data);`**<br>
- 리스트에 데이터를 저장한다. 매개변수 `data`에 전달된 값을 저장한다.<br>
<br>

**`int LFirtst(List * plist, Ldata * pdata);`**<br>
- 첫 번째 데이터가 `pdata`가 가리키고 있는 메모리에 저장된다.<br>
- 데이터의 참조를 위한 초기화가 이루어진다.<br>
- 참조 성공 시 `TRUE(1)`, 실패 시 `FALSE(0)`을 반환한다.<br>
<br>

**`int LNext(List * plist, Ldata * pdata);`**<br>
- 현재 참조되고 있는 데이터 다음으로 들어갈 데이터가 `pdata`가 가리키고 있는 메모리에 저장된다.<br>
- 순차적인 참조를 위해서 반복 호출이 가능하다.<br>
- 참조를 새로 시작하려면, 먼저 `LFirst`함수를 호출해야 한다. 데이터 탐색 및 참조의 기준은 항상 `LFist`함수이다.<br>
- 참조 성공 시 `TRUE(1)`, 실패 시, `FALSE(0)`을 반환한다.<br>
<br>

**`LData LRemove(List * plist);`**<br>
- `LFirst`혹은 `LNext`함수의 마지막 반환 데이터를 삭제한다.<br>
- 삭제된 데이터는 반환된다.<br>
- 마지막 반환 데이터를 삭제하므로 연이은 반복호출은 허용하지 않는다.<br>
<br>

**`int LCount(List * plist);`**<br>
- 리스트에 저장된 데이터의 개수를 반환한다.<br>
<br>

**`void SetSortRule(List * plist, int (*comp)(LData d1, LData d2);`**
- 리스트의 정렬의 기준이 되는 함수를 등록한다.<br>
<br>

## 더미 노드(Dummy Node) 기반의 단순 연결 리스트

### 새 노드의 추가 위치에 따른 장점과 단점

- #### 새 노드를 연결 리스트의 머리에 추가하는 경우
  장점 : 포인터 변수 `tail`이 불필요하다.<br>
  > 새로운 노드를 꼬리에 추가하는 경우, 새로 추가하고자 하는 노드를 링크드 리스트의 마지막 노드에 연결하여 추가하는 것이기 때문에,<br>
  > 이 마지막 노드를 가리키는 포인터 변수 `tail`이 필요하다.<br><br>
  > 하지만, 이러한 포인터 변수 `tail`을 유지하기 위해서 넣어야할 부가적인 코드들이 번거롭게 느껴질 수 있으며, 리스트 자료구조는<br>
  > 저장된 순서를 유지해야 하는 자료구조가 아니다.<br>

  <br>

  단점 : 저장된 순서를 유지하지 않는다.<br>
  > 새로운 노드를 링크들 리스트의 머리(head)에 추가하는 경우, 예를 들어, `1`, `2`, `3` 이라는 데이터를 저장한다고 할 때, 아래와<br>
  > 같이, 데이터를 저장한 순서의 역순으로 저장이 된다.<br><br>
  > `3` -> `2` -> `1` <br>
  > 첫 번째로 링크드 리스트의 머리에 저장된 값인 1을 다음에 저장된 2가 가리키고, 3이 2를 가리킴.<br>
  > 즉, 데이터가 저장된 순서를 유지하지 않는다.<br><br>
  > 
  > 구현자 입장에서는, 저장된 데이터의 순서를 유지하는 것이 더욱 편할 수도 있지만, 위에서 말했다시피, 리스트 자료구조는 데이터가<br>
  > 저장된 순서를 유지해야 하는 자료구조가 아니다.<br>

  이렇게, 새 노드를 연결리스트의 머리에 추가하는 경우, 데이터가 저장된 순서를 유지하지는 않지만, 포인터 변수 `tail`이 불필요하여,<br>
  이와 관련된 부가적인 코드를 작성하지 않아도 된다는 장점이 있다.<br>
<br>

### 연결 리스트의 정렬 기준을 지정하기 위한 함수 - `SetSortRule`, 함수 포인터에 관한 간단한 설명
이번 연결 리스트의 ADT를 작성하면서, 새롭게 추가한 리스트의 정렬 기준을 지정하기 위한 함수`SetSortRule`의 선언문은 아래와 같다.<br>
```c
void SetSortRule(List * plist, int (*comp)(LData d1, LData d2));
```
<br>

여기서 `int (*comp)(LData d1, LData d2)`를 한번 봐 보자.<br>
이러한 문장의 형태는 함수의 주소값을 저장하는 함수 포인터의 선언 패턴으로, 이를 나누어서 해석해 보면 다음과 같다.<br>
<br>


```c
int /*(*comp)(LData d1, LData d2)*/
```
> 반환형이 `int`이고<br>
<br>

```c
/*int (*comp)*/(LData d1, LData d2)
```
> `LData`형 인자 2개를 전달받는<br>
<br>


```c
/*int*/(*comp)/*(LData d1, Ldata d2)*/
```
> 함수의 주소값을 포인터 변수 `comp`에 저장하라!<br>
<br>


먼저, `(*comp)`를 통해, `comp`라는 변수가 포인터 변수임을 선언해 주었다.<br>

그렇다면, 이 `comp`라는 포인터 변수는 무엇을 가리키는 포인터 변수일까?<br>

바로, `(*comp)`를 기준으로, 왼쪽에 있는 반환형 `int`와 오른쪽에 있는 매개변수 선언 `(LData d1, LData d2)`을 가지고 있는<br>
함수의 주소값을 저장할 수 있는 포인터 변수인 것이다.<br>

따라서, 해당 문장은 반환형이 `int`형이고, 매개변수에 `LData`형 인자 2개를 전달받는 함수의 주소값을 저장하는 포인터 변수<br>
`comp`의 선언문이라 할 수 있다.<br>
<br>

### `SetSortRule`함수를 통해서, 리스트에 적용하고자 하는 기능
`SetSortRule`함수는 연결 리스트의 정렬 기준을 지정하기 위한 함수이다.<br>

이번에 구현해볼 단순 연결 리스트는 리스트의 머리(head)에 노드를 추가하는 방식이므로, 리스트의 마지막 노드를 가리키는 포인터 변수<br>
`tail`에 관한 코드를 작성하지 않아도 된다는 장점이 있지만, 저장된 데이터(노드)의 순서(정렬순서)를 그대로 유지하지 못한다.<br>

그래서, 정렬의 기준을 나타내는 함수를 전달받아, 해당 정렬 기준을 연결 리스트에 적용시키는 `SetSortRule`함수를 추가하였다.<br>

즉, 어떤 정렬 기준을 나타내는 함수를 `SetSortRule`함수에 전달해 주었느냐에 따라, 코드를 수정하지 않고도, 해당 연결 리스트의 정렬
<br>기준이 바뀌는 것이다.<br>
(이것이 가능한 이유는 "함수 포인터"가 가지는 의미가 이렇기 때문. 리스트 자료구조의 코드를 수정하지 않고도, 정렬 기준을 나타내는<br>
함수를 전달받음으로써 연결 리스트의 행동 패턴/내용이 달라질 수 있다.)<br>









  




