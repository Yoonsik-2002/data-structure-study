# 단순 연결 리스트(Singly Linked List)
연결의 형태가 한쪽 방향으로 전개되고, 시작과 끝이 분명히 존재하는 리스트 자료구조이다.<br>
<br>

## 📝 단순 연결 리스트의 ADT
이번에 공부해 볼 단순 연결 리스트의 ADT를 정리해 보도록 하겠다.<br>

**`void ListInit(List * plist);`**<br>
- 생성할 리스트의 초기화를 담당하는 기능이다.<br>
- 리스트 생성 후, 제일 먼저 호출해야 하는 기능이다.<br>
<br>

**`void LInsert(List * plist, LData data);`**<br>
- 리스트에 데이터를 저장한다. 매개변수 `data`에 전달된 값을 저장한다.<br>
<br>

**`int LFirtst(List * plist, Ldata * pdata);`**<br>
- 첫 번째 데이터가 `pdata`가 가리키고 있는 메모리에 저장된다.<br>
- 데이터의 참조를 위한 초기화가 이루어진다.<br>
- 참조 성공 시 `TRUE(1)`, 실패 시 `FALSE(0)`을 반환한다.<br>
<br>

**`int LNext(List * plist, Ldata * pdata);`**<br>
- 현재 참조되고 있는 데이터 다음으로 들어갈 데이터가 `pdata`가 가리키고 있는 메모리에 저장된다.<br>
- 순차적인 참조를 위해서 반복 호출이 가능하다.<br>
- 참조를 새로 시작하려면, 먼저 `LFirst`함수를 호출해야 한다. 데이터 탐색 및 참조의 기준은 항상 `LFist`함수이다.<br>
- 참조 성공 시 `TRUE(1)`, 실패 시, `FALSE(0)`을 반환한다.<br>
<br>

**`LData LRemove(List * plist);`**<br>
- `LFirst`혹은 `LNext`함수의 마지막 반환 데이터를 삭제한다.<br>
- 삭제된 데이터는 반환된다.<br>
- 마지막 반환 데이터를 삭제하므로 연이은 반복호출은 허용하지 않는다.<br>
<br>

**`int LCount(List * plist);`**<br>
- 리스트에 저장된 데이터의 개수를 반환한다.<br>
<br>

**`void SetSortRule(List * plist, int (*comp)(LData d1, LData d2);`**
- 리스트의 정렬의 기준이 되는 함수를 등록한다.<br>
<br>

### 새 노드의 추가 위치에 따른 장점과 단점

- #### 새 노드를 연결 리스트의 머리에 추가하는 경우
  장점 : 포인터 변수 `tail`이 불필요하다.<br>
  > 새로운 노드를 꼬리에 추가하는 경우, 새로 추가하고자 하는 노드를 링크드 리스트의 마지막 노드에 연결하여 추가하는 것이기 때문에,<br>
  > 이 마지막 노드를 가리키는 포인터 변수 `tail`이 필요하다.<br><br>
  > 하지만, 이러한 포인터 변수 `tail`을 유지하기 위해서 넣어야할 부가적인 코드들이 번거롭게 느껴질 수 있으며, 리스트 자료구조는<br>
  > 저장된 순서를 유지해야 하는 자료구조가 아니다.<br>

  <br>

  단점 : 저장된 순서를 유지하지 않는다.<br>
  > 새로운 노드를 링크들 리스트의 머리(head)에 추가하는 경우, 예를 들어, `1`, `2`, `3` 이라는 데이터를 저장한다고 할 때, 아래와<br>
  > 같이, 데이터를 저장한 순서의 역순으로 저장이 된다.<br><br>
  > `3` -> `2` -> `1` <br>
  > 첫 번째로 링크드 리스트의 머리에 저장된 값인 1을 다음에 저장된 2가 가리키고, 3이 2를 가리킴.<br>
  > 즉, 데이터가 저장된 순서를 유지하지 않는다.<br><br>
  > 
  > 구현자 입장에서는, 저장된 데이터의 순서를 유지하는 것이 더욱 편할 수도 있지만, 위에서 말했다시피, 리스트 자료구조는 데이터가<br>
  > 저장된 순서를 유지해야 하는 자료구조가 아니다.<br>
  <br>
  
  이렇게, 새 노드를 연결리스트의 머리에 추가하는 경우, 데이터가 저장된 순서를 유지하지는 않지만, 포인터 변수 `tail`이 불필요하여,<br>
  이와 관련된 부가적인 코드를 작성하지 않아도 된다는 장점이 있다.<br>
  (비교적 많은 자료구조 서적들도, 노드를 머리(head)에 추가하는 방식으로 연결리스트를 구현한다.)<br>
<br>

### 연결 리스트의 정렬 기준을 지정하기 위한 함수 - `SetSortRule`, 함수 포인터에 관한 간단한 설명
이번 연결 리스트의 ADT를 작성하면서, 새롭게 추가한 리스트의 정렬 기준을 지정하기 위한 함수`SetSortRule`의 선언문은 아래와 같다.<br>
```c
void SetSortRule(List * plist, int (*comp)(LData d1, LData d2));
```
<br>

여기서 `int (*comp)(LData d1, LData d2)`를 한번 봐 보자.<br>
이러한 문장의 형태는 함수의 주소값을 저장하는 함수 포인터의 선언 패턴으로, 이를 나누어서 해석해 보면 다음과 같다.<br>
<br>


```c
int /*(*comp)(LData d1, LData d2)*/
```
> 반환형이 `int`이고<br>
<br>

```c
/*int (*comp)*/(LData d1, LData d2)
```
> `LData`형 인자 2개를 전달받는<br>
<br>


```c
/*int*/(*comp)/*(LData d1, Ldata d2)*/
```
> 함수의 주소값을 포인터 변수 `comp`에 저장하라!<br>
<br>


먼저, `(*comp)`를 통해, `comp`라는 변수가 포인터 변수임을 선언해 주었다.<br>

그렇다면, 이 `comp`라는 포인터 변수는 무엇을 가리키는 포인터 변수일까?<br>

바로, `(*comp)`를 기준으로, 왼쪽에 있는 반환형 `int`와 오른쪽에 있는 매개변수 선언 `(LData d1, LData d2)`을 가지고 있는<br>
함수의 주소값을 저장할 수 있는 포인터 변수인 것이다.<br>

따라서, 해당 문장은 반환형이 `int`형이고, 매개변수에 `LData`형 인자 2개를 전달받는 함수의 주소값을 저장하는 포인터 변수<br>
`comp`의 선언문이라 할 수 있다.<br>
<br>

### `SetSortRule`함수를 통해서, 리스트에 적용하고자 하는 기능
`SetSortRule`함수는 연결 리스트의 정렬 기준을 지정하기 위한 함수이다.<br>

이번에 구현해볼 단순 연결 리스트는 리스트의 머리(head)에 노드를 추가하는 방식이므로, 리스트의 마지막 노드를 가리키는 포인터 변수<br>
`tail`에 관한 코드를 작성하지 않아도 된다는 장점이 있지만, 저장된 데이터(노드)의 순서(정렬순서)를 그대로 유지하지 못한다.<br>

그래서, 정렬의 기준을 나타내는 함수를 전달받아, 해당 정렬 기준을 연결 리스트에 적용시키는 `SetSortRule`함수를 추가하였다.<br>

즉, 어떤 정렬 기준을 나타내는 함수를 `SetSortRule`함수에 전달해 주었느냐에 따라, 코드를 수정하지 않고도, 해당 연결 리스트의 정렬
<br>기준이 바뀌는 것이다.<br>
(이것이 가능한 이유는 "함수 포인터"가 가지는 의미가 이렇기 때문. 리스트 자료구조의 코드를 수정하지 않고도, 정렬 기준을 나타내는<br>
함수를 전달받음으로써 연결 리스트의 행동 패턴/내용이 달라질 수 있다.)<br>

```c
void SetSortRule(List * plist, int (*comp)(LData d1, LData d2));
```
<br>

우리는 위 `SetSortRule`함수를 통해, 정렬기준을 리스트에 설치하여, 연결 리스트가 설치된 정렬기준에 맞게 동작하도록 만들 수 있다.<br>

바로, `SetSortRule`의 두 번째 매개변수, 함수 포인터 `int (*comp)(LData d1, LData d2)`로의 정렬기준을 나타내는 함수의 전달을<br>
통해서 말이다!<br>

이때, 함수 포인터 변수 `comp`에 전달될 수 있는 함수의 조건은 다음과 같다.<br>

**반환형은 int형 이어야 하고, 매개변수에 인자로 전달되는 값은 `LData`타입의 변수 2개여야 한다.** <br>

자, 그럼 한번 `SetSortRule`함수의 두번째 인자로 전달되는 함수를 한번 정의해 보도록 하겠다.<br>

`typedef int LData` <- 노드의 저장되는 데이터의 값이 int형이라 가정하고, 해당 연결리스트의 노드가 저장하고 있는 데이터 기준,<br>
오름차순으로 정렬되도록 하는 함수, `WhoIsPrecede`이다.<br>

`WhoIsPrecede`함수를 정의하는데 있어, 제일 먼저 따져보아야 할 조건은 해당 함수의 반환형과 매개변수이다.<br>
그리고, 해당 함수가 반환하는 값이 어떤 의미를 갖는지는 연결리스트를 구현하는 본인이 결정할 문제이다.<br>

나는 `WhoIsPrecede`함수를 정의하는데 있어, 다음 조건을 갖춰 정의해야 하는 것으로 결정하였다.<br>

> 함수의 반환형은 int형이고, 매개변수는 `LData`타입의 변수, `d1`, `d2`이다. 그리고, 인자로 전달받은 `d1`값이 head에 더 가까<br>
> 워야 하는 경우에는 0을 반환하고, `d2`값이 head에 더 가까워야 하거나 같은 경우에는 1을 반환한다.<br>

이때, 구현하고자 하는 정렬기준이 '오름차순'이기에, 인자로 전달받은 `d1`, `d2` 값 중, 더 작은 값이 head에 가까워야 한다.<br>

이를 토대로 `WhoIsPrecede`함수를 구현해 보면 다음과 같다.<br>

```c
int WhoIsPrecede(LData d1, LData d2) {
  if(d1 < d2) // d1이 d2보다 더 작은 경우
    return 0; // d1이 head와 더 가깝다(앞선다).

  else // d2가 d1보다 더 작거나 같은 경우
    return 1; // d2가 head와 더 가깝거나 같다.
}
```
<br>

해당 함수에서는 `d1`이 `d2`보다 작아서 `d1`을 head와 더 가깝게 배치해야 하는 경우에는 `0`을 리턴하도록,<br>
`d2`가 `d1`보다 작아서 `d2`를 head와 더 가깝게 배치해야 하는 경우에는 `1`을 리턴하도록 리턴값의 의미를 지정해 주었다.<br>

함수 포인터에 전달되는 함수의 반환값의 의미는 이를 구현하는 본인이 결정하는 것이다!<br>
일단 이 점을 기억하고, `SetSortRule`함수가 어떻게 활용되고, 또 연결 리스트 내부적으로 어떠한 의미를 지니는지는<br>
해당 함수를 구현할 때 더욱 자세히 다뤄보도록 하겠다.<br>




  





  




