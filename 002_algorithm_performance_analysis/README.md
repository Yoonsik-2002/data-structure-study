## 시간 복잡도와 공간 복잡도
시간 복잡도와 공간 복잡도는 알고리즘을 평가하는 두 가지 요소이다. 
- #### 시간 복잡도
  시간 복잡도는 어떤 상황에서 어떤 알고리즘이 **수행속도가 빠르거나 느린가?** (CPU에 부담이 얼마나 가는가?) 를 분석한 결과이다.
- #### 공간 복잡도
  공간 복잡도는 어떤 상황에서 어떤 알고리즘이 **메모리 공간을 적게 쓰거나 많이 쓰는가?** (메모리 사용량이 얼마나 많거나 적은가?) 를 분석한 결과이다. 
  
이 알고리즘을 평가하는 두 가지 요소인, **시간 복잡도와 공간 복잡도** 중 더욱 중요도가 높은것은 바로 **시간 복잡도** 이다.<br>
왜냐하면, 공간복잡도의 경우, 메모리를 얼마나 많이 쓰거나 적게 쓰는가를 평가하는 요소인데 알고리즘은 시작부터 끝까지 하나의 메모리를 누적해서 사용하지 않는다.<br><br>
대표적인 예로, 지역적으로 선언된 변수나 배열을 생각해 보자. 지역적으로 선언된 것들은 해당 지역을 벗어나게 되면, 메모리 상에서 지워지게 된다. 즉, 메모리 상에 썼다 지웠다가 반복되는
형태를 띄는 것이다.<br>

결국 공간 복잡도는 알고리즘이 얼마나 많이 메모리 공간을 사용하는가? 보다는 얼마나 많이 메모리 공간을 생성하고 삭제는가? 즉, 메모리에 접근에 따른 시간이 얼마나 소요되는가? 를 따지게
되며, 결론적으로 공간복잡도의 문제는 시간에 귀결되게 된다.<br>

**알고리즘에 있어, 공간 복잡도와 관련된 메모리에 접근에 관한 문제는 시간 복잡도와 관련된 CPU에 부담이 얼마나 가는가? 에 관한 문제에 비하면 아주 중요도가 낮은 문제이다. 때문에, 공간복잡도는 알고리즘을 평가하는 보조적인 요소 라고 볼 수 있다.**
<br><br>


## 순차 탐색(Linear Search) 알고리즘과 시간 복잡도 분석
순차탐색 알고리즘이란 말 그대로 앞에서부터 뒤로 **순차적으로 탐색해 나아가는 알고리즘**이다.<br>
예를 들어, 배열이 하나 있다고 가정해 보자. 우리는 이 배열에 어떤 값들이 저장되어 있는지모른다. 우리는 이 배열에 숫자 7이 들어 있는지 확인해보기 위해 순차 탐색 알고리즘을 사용하였다.<br><br>
해당 배열에 순차탐색 알고리즘을 적용하면 다음과 같은 일이 발생한다.<br>
배열의 첫 번째 인덱스(index 0)에 저장되어 있는 값 부터 마지막 인덱스에 저장되어 있는 값까지 순차적으로 찾고자 하는 값 7과 일치한지 비교하여 탐색한다.<br>
만약 찾고자 하는 값을 해당 배열에서 찾았다면 찾은 값을 저장하고 있는 배열의 인덱스의 값을 반환한다. <br>
그리고 만약 찾고자 하는 값을 해당 배열에서 찾지 못하였다면, "찾지 못했음" 을 의미하는 값 (-1) 을 반환한다. 

### 순차탐색 알고리즘을 적용한 함수 `linear_serch`
```c
int linear_search(int target, int array_length, int ex_arr[]) {
  int i;
	
  for(i = 0; i < array_length; i++){
    if(ex_arr[i] == target)
    return i; // 값을 찾은 배열의 인덱스 값을 반환하고 함수 종료
  }
	return -1; // 배열의 처음부터 끝까지 비교하였지만 값을 찾지 못한 경우. 값을 찾지 못하였음을 의미하는 값(-1) 을 반환하고 함수 종료
}
```
### 순차탐색 알고리즘의 시간복잡도 분석
알고리즘의 시간복잡도 즉, 수행속도를 평가할 때는 실제로 알고리즘의 수행시간이 얼마나 걸리는지 타이머로 측정하는 것이 아니라, 다음과 같은 방식을 사용한다. 
- 연산의 횟수를 센다.
- 처리해야 할 데이터의 양 `n` 에 따른 연산의 횟수를 나타내는 T(n) 함수를 구성한다.<br>

즉, 연산 횟수를 통해 알고리즘의 수행 속도를 판단하고, 처리해야할 데이터의 양에 따라 알고리즘의 연산 횟수(알고리즘의 속도)가 어떻게 변화하는지를 나타내는 T(n) 함수를 구성하여 데이터 
수에 따른 알고리즘의 수행속도를 나타낸다.<br>
*자, 그러면 순차 탐색 알고리즘의 시간복잡도를 분석해 보도록 하겠다.*

순차적으로 값을 비교하여 특정 값을 탐색하며 찾아내는 **`linear_search`** 함수에서, 실질적으로 **탐색** 이라는 기능을 구현하는 코드만 떼어내 보면 다음과 같다.
```c
for(i = 0; i < array_length; i++){
  if(ex_arr[i] == target)
  return i; // 값을 찾은 배열의 인덱스 값을 반환하고 함수 종료
}
```
해당 알고리즘에서 보이는 연산자는 **`<`**, **`++`**, **`==`** 가 있다. 그럼, 이 순차 탐색 알고리즘의 시간 복잡도를 분석하기 위해서는 해당 연산자들의 <br>연산 횟수를 세면 되는 걸까? 답은 '아니다'.<br>

*알고리즘의 수행시간을 평가하기 위해서는 해당 알고리즘에 사용된 모든 연산의 횟수를 세는 것이 아니라, **중심이 되는 연산의 연산 횟수** 를 세야 한다!*<br>

그럼, 중심이 되는 연산이란 무엇인가? 탐색 알고리즘은 값을 비교하여 탐색하는 알고리즘이다. 즉, 해당 알고리즘에서의 핵심은 값을 비교하는 데에 있다. 이때, **`<`**, **`++`**, **`==`** 연산자 중, 값의 비교를 담당하는 연산자는 바로 **`==`** 연산자이고, **이 `==` 연산자를 이용한 값의 동등을 비교하는 연산이 해당 알고리즘의 중심이 되는 연산이라 할 수 있다.**<br>

이러한 중심이 되는 연산자는 다음과 같은 특징을 가진다. 
> 주변에 있는 연산자의 수행 횟수가 중심이 되는 연산자의 수행 횟수에 의존적이다. 즉, 중심이 되는 연산자의 수행 횟수에 따라 주변에 있는 연산자의 수행 횟수가 결정된다.<br>

위 코드를 보면, 배열 내에서 동등한 값을 찾지 못해, **`==`** 연산이 늘어나면 **`<`**, **`++`** 연산 또한 수행 횟수가 늘어나게 되고, 배열 내에서 동등한 값을 금방 찾아 **`==`** 연산 횟수가 줄어들게 되면  **`<`**, **`++`** 연산 또한 수행 횟수가 줄어들게 되는 것을 알 수 있다. 즉, 중심이 되는 **`==`** 연산의 수행 횟수에 주변 연산자들의 수행 횟수가 의존적인 것을 알 수 있다. 

### 순차탐색 알고리즘의 시간복잡도 분석하기 - 최선의 경우(best case), 최악의 경우(worst case), 평균적인 경우(average case)
모든 알고리즘에는 최선의 경우(best case), 최악의 경우(worst case), 평균적인 경우(average case) 가 존재한다. 순차탐색 알고리즘의 경우를 한번 보도록 하자.

### 최선의 경우(best case)
순차탐색 알고리즘의 시간 복잡도를 계산할 때 가장 최선의 경우는 무엇일까? 바로 해당 알고리즘의 중심이 되는 연산인 == 연산을 가장 적게하는 경우이다. 즉, **찾고자(탐색)하는 값을 배열의 첫 번째 요소(index 0) 에서 바로 찾은 경우** 라고 할 수 있겠다. == 연산을 한 번만 수행하면 되기 때문이다.<br>

*최선의 경우에서 순차탐색 알고리즘의 시간복잡도를 계산해 보도록 하겠다.*<br>

최선의 경우, 데이터의 수 n 에 따른 연산 횟수를 나타내는 함수 T(n)은 다음과 같다. T(n) = 1<br>
최선의 경우에는 데이터의 수 (배열의 길이)가 어떻든 간에 연산을 한 번만 하면 되기 때문에, T(n) = 1 이라는 결과가 나오게 된다.<br>

이렇게 최선의 경우에서 순차탐색 알고리즘의 시간복잡도를 계산해 보았다. 하지만 아쉅게도 최선의 경우는 알고리즘을 평가하는데 있어, 크게 고려할 사항이 되지 못한다. 왜냐하면, 대부분의 알고리즘은 최선의 경우일 때 만족스러운 결과를 보이기 때문이다.(어떤 알고리즘을 사용해도 뚜렷한 차이 없음)

### 최악의 경우(worst case)
그럼, 반대로 순차탐색 알고리즘의 시간 복잡도를 계산할 때 가장 최악의 경우는 무엇일까? 최선의 경우와는 반대로 중심이 되는 연산인 == 연산을 가장 많이 하게 되는 경우 일 것이다.<br>
즉, **찾고자 하는 값이 가장 마지막에 있거나 배열 전체를 다 돌아도 찾지 못하는 경우** 라고 할 수 있겠다. 만약, 배열의 길이가 n일 경우, n 만큼 반복하여 순차적으로 값을 비교해야 하기 때문이다.<br>
값을 배열의 처음 부터 끝까지 순차적으로 탐색하는 순차 탐색 알고리즘의 경우, == 연산을 가장 많이 하게 되는 경우는 배열의 길이 만큼 값을 비교하는 경우이다.<br>

*최악의 경우에서 순차탐색 알고리즘의 시간복잡도를 계산해 보도록 하겠다.*<br>

최악의 경우, 데이터의 수 n 에 따른 연산 횟수를 나타내는 함수 T(n)은 다음과 같다. T(n) = n<br>
해당 순차탐색 알고리즘의 데이터의 수 n 은 배열의 길이와 같다. 이때, 최악의 경우는 배열의 길이(데이터의 수) 만큼 값을 순차적으로 비교하였을 때, 찾고자 하는 값이 가장 마지막에 있거나, 마지막까지 찾지 못한 경우로, 데이터의 수(배열의 길이)와 연산 횟수가 같은 경우이다.<br>
때문에, T(n) = n 이라는 결과가 나오게 된다.<br>

알고리즘을 평가하는데 있어 중요한 것은 바로 이 최악의 경우일 때이다. 왜냐하면, 데이터의 수가 많아짐에 따라 최악의 경우에 수행하게 되는 연산의 횟수는 최선의 경우와는 달리 알고리즘 별로 큰 차이를 보이게된다. 때문에, 알고리즘을 평가하는데 있어, 중요한 것은 최악의 경우라고 할 수 있다. 

### 평균적인 경우(average case)
마지막으로, 순차탐색 알고리즘의 시간 복잡도를 계산할 때 평균적인 경우는 무엇일까? 이에 대해서는 답변하기 쉽지 않다. 애초에 무엇이 평균적인 경우인지도 주장하기 쉽지 않을 것이다. 순차 탐색 알고리즘의 경우 비교적 간단 하지만, 다른 알고리즘의 경우, 평균적인 경우가 무엇인지를 주장하기 위해서는 다양한 자료들이 광범위하게 수집되어야 하며, 또 이를 계산하는 데에도 다양한 이론과 여러 시나리오, 데이터를 합리적으로 구성해야 한다.<br>
때문에, **알고리즘 평가에는 가장 신뢰도가 높고 논란이 소지가 거의 없는 최악의 경우(worst case)가 선택될 수 밖에 없다.**  
<br><br>


## 이진탐색 알고리즘
이진탐색이란 데이터가 정렬되어 있을 때, 해당 데이터들의 중앙값과 찾고자 하는 값을 비교하여 검색 대상을 반씩 줄여 나가는 방식이다. 이떄, 데이터가 정렬되어 있지 않을 경우, 중앙값이 무엇인지 알 수 없기 때문에 **이진탐색을 사용하기 위해서는 탐색 대상이 되는 데이터들이 무조건 정렬되어있어야 한다.**(이진탐색은 정렬된 데이터가 아니면 적용이 불가능함)<br>
> 중앙값이란?
  중앙값(중위수)는 어떤 주어진 값들을 크기의 순서대로 나열 하였을 때, 가장 중앙에 위치하는 값을 의미한다. 
