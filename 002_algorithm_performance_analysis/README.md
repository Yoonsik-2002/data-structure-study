## 시간 복잡도와 공간 복잡도
시간 복잡도와 공간 복잡도는 알고리즘을 평가하는 두 가지 요소이다. 
- #### 시간 복잡도
  시간 복잡도는 어떤 상황에서 어떤 알고리즘이 **수행속도가 빠르거나 느린가?** (CPU에 부담이 얼마나 가는가?) 를 분석한다.
- #### 공간 복잡도
  공간 복잡도는 어떤 상황에서 어떤 알고리즘이 **메모리 공간을 적게 쓰거나 많이 쓰는가?** (메모리 사용량이 얼마나 많거나 적은가?) 를 분석한다. 
  
이 알고리즘을 평가하는 두 가지 요소인, **시간 복잡도와 공간 복잡도** 중 더욱 중요도가 높은것은 바로 **시간 복잡도** 이다.<br>
왜냐하면, 공간복잡도의 경우, 메모리를 얼마나 많이 쓰거나 적게 쓰는가를 평가하는 요소인데 알고리즘은 시작부터 끝까지 하나의 메모리를 누적해서 사용하지 않는다.<br><br>
대표적인 예로, 지역적으로 선언된 변수나 배열을 생각해 보자. 지역적으로 선언된 것들은 해당 지역을 벗어나게 되면, 메모리 상에서 지워지게 된다. 즉, 메모리 상에 썼다 지웠다가 반복되는
형태를 띄는 것이다.<br>

결국 공간 복잡도는 알고리즘이 얼마나 많이 메모리 공간을 사용하는가? 보다는 얼마나 많이 메모리 공간을 생성하고 삭제는가? 즉, 메모리에 접근에 따른 시간이 얼마나 소요되는가? 를 따지게
되며, 결론적으로 공간복잡도의 문제는 시간에 귀결되게 된다.<br>

**알고리즘에 있어, 공간 복잡도와 관련된 메모리에 접근에 관한 문제는 시간 복잡도와 관련된 CPU에 부담이 얼마나 가는가? 에 관한 문제에 비하면 아주 중요도가 낮은 문제이다. 때문에, 공간복잡도는 알고리즘을 평가하는 보조적인 요소 라고 볼 수 있다.**

<br><br>


## 순차 탐색(Linear Search) 알고리즘과 시간 복잡도 분석
순차탐색 알고리즘이란 말 그대로 앞에서부터 뒤로 **순차적으로 탐색해 나아가는 알고리즘**이다.<br>
예를 들어, 배열이 하나 있다고 가정해 보자. 우리는 이 배열에 어떤 값들이 저장되어 있는지모른다. 우리는 이 배열에 숫자 7이 들어 있는지 확인해보기 위해 순차 탐색 알고리즘을 사용하였다.<br><br>
해당 배열에 순차탐색 알고리즘을 적용하면 다음과 같은 일이 발생한다.<br>
배열의 첫 번째 인덱스(index 0)에 저장되어 있는 값 부터 마지막 인덱스에 저장되어 있는 값까지 순차적으로 찾고자 하는 값 7과 일치한지 비교하여 탐색한다.<br>
만약 찾고자 하는 값을 해당 배열에서 찾았다면 찾은 값을 저장하고 있는 배열의 인덱스의 값을 반환한다. <br>
그리고 만약 찾고자 하는 값을 해당 배열에서 찾지 못하였다면, "찾지 못했음" 을 의미하는 값 (-1) 을 반환한다. 

### 순차탐색 알고리즘을 적용한 함수 `linear_serch`
```c
int linear_search(int target, int array_length, int ex_arr[]) {
	int i;
	
	for(i = 0; i < array_length; i++){
		if(ex_arr[i] == target)
			return i; // 값을 찾은 배열의 인덱스 값을 반환하고 함수 종료
	}
	return -1; // 배열의 처음부터 끝까지 비교하였지만 값을 찾지 못한 경우. 값을 찾지 못하였음을 의미하는 값(-1) 을 반환하고 함수 종료
}
```
