## 시간 복잡도와 공간 복잡도
시간 복잡도와 공간 복잡도는 알고리즘을 평가하는 두 가지 요소이다. 
- #### 시간 복잡도
  시간 복잡도는 어떤 상황에서 어떤 알고리즘이 **수행속도가 빠르거나 느린가?** (CPU에 부담이 얼마나 가는가?) 를 분석한 결과이다.
- #### 공간 복잡도
  공간 복잡도는 어떤 상황에서 어떤 알고리즘이 **메모리 공간을 적게 쓰거나 많이 쓰는가?** (메모리 사용량이 얼마나 많거나 적은가?) 를 분석한 결과이다. 
  
이 알고리즘을 평가하는 두 가지 요소인, **시간 복잡도와 공간 복잡도** 중 더욱 중요도가 높은것은 바로 **시간 복잡도** 이다.<br>
왜냐하면, 공간복잡도의 경우, 메모리를 얼마나 많이 쓰거나 적게 쓰는가를 평가하는 요소인데 알고리즘은 시작부터 끝까지 하나의 메모리를 누적해서 사용하지 않는다.<br><br>
대표적인 예로, 지역적으로 선언된 변수나 배열을 생각해 보자. 지역적으로 선언된 것들은 해당 지역을 벗어나게 되면, 메모리 상에서 지워지게 된다. 즉, 메모리 상에 썼다 지웠다가 반복되는
형태를 띄는 것이다.<br>

결국 공간 복잡도는 알고리즘이 얼마나 많이 메모리 공간을 사용하는가? 보다는 얼마나 많이 메모리 공간을 생성하고 삭제는가? 즉, 메모리에 접근에 따른 시간이 얼마나 소요되는가? 를 따지게
되며, 결론적으로 공간복잡도의 문제는 시간에 귀결되게 된다.<br>

**알고리즘에 있어, 공간 복잡도와 관련된 메모리에 접근에 관한 문제는 시간 복잡도와 관련된 CPU에 부담이 얼마나 가는가? 에 관한 문제에 비하면 아주 중요도가 낮은 문제이다. 때문에, 공간복잡도는 알고리즘을 평가하는 보조적인 요소 라고 볼 수 있다.**
<br><br>


## 순차 탐색(Linear Search) 알고리즘과 시간 복잡도 분석
순차탐색 알고리즘이란 말 그대로 앞에서부터 뒤로 **순차적으로 탐색해 나아가는 알고리즘**이다.<br>
예를 들어, 배열이 하나 있다고 가정해 보자. 우리는 이 배열에 어떤 값들이 저장되어 있는지모른다. 우리는 이 배열에 숫자 7이 들어 있는지 확인해보기 위해 순차 탐색 알고리즘을 사용하였다.<br><br>
해당 배열에 순차탐색 알고리즘을 적용하면 다음과 같은 일이 발생한다.<br>
배열의 첫 번째 인덱스(index 0)에 저장되어 있는 값 부터 마지막 인덱스에 저장되어 있는 값까지 순차적으로 찾고자 하는 값 7과 일치한지 비교하여 탐색한다.<br>
만약 찾고자 하는 값을 해당 배열에서 찾았다면 찾은 값을 저장하고 있는 배열의 인덱스의 값을 반환한다. <br>
그리고 만약 찾고자 하는 값을 해당 배열에서 찾지 못하였다면, "찾지 못했음" 을 의미하는 값 (-1) 을 반환한다. 

### 순차탐색 알고리즘을 적용한 함수 `linear_serch`
```c
int linear_search(int target, int array_length, int ex_arr[]) {
  int i;
	
  for(i = 0; i < array_length; i++){
    if(ex_arr[i] == target)
    return i; // 값을 찾은 배열의 인덱스 값을 반환하고 함수 종료
  }
	return -1; // 배열의 처음부터 끝까지 비교하였지만 값을 찾지 못한 경우. 값을 찾지 못하였음을 의미하는 값(-1) 을 반환하고 함수 종료
}
```
### 순차탐색 알고리즘의 시간복잡도 분석
알고리즘의 시간복잡도 즉, 수행속도를 평가할 때는 실제로 알고리즘의 수행시간이 얼마나 걸리는지 타이머로 측정하는 것이 아니라, 다음과 같은 방식을 사용한다. 
- 연산의 횟수를 센다.
- 처리해야 할 데이터의 양 `n` 에 따른 연산의 횟수를 나타내는 T(n) 함수를 구성한다.<br>

즉, 연산 횟수를 통해 알고리즘의 수행 속도를 판단하고, 처리해야할 데이터의 양에 따라 알고리즘의 연산 횟수(알고리즘의 속도)가 어떻게 변화하는지를 나타내는 T(n) 함수를 구성하여 데이터 
수에 따른 알고리즘의 수행속도를 나타낸다.<br>
*자, 그러면 순차 탐색 알고리즘의 시간복잡도를 분석해 보도록 하겠다.*

순차적으로 값을 비교하여 특정 값을 탐색하며 찾아내는 **`linear_search`** 함수에서, 실질적으로 **탐색** 이라는 기능을 구현하는 코드만 떼어내 보면 다음과 같다.
```c
for(i = 0; i < array_length; i++){
  if(ex_arr[i] == target)
  return i; // 값을 찾은 배열의 인덱스 값을 반환하고 함수 종료
}
```
해당 알고리즘에서 보이는 연산자는 **`<`**, **`++`**, **`==`** 가 있다. 그럼, 이 순차 탐색 알고리즘의 시간 복잡도를 분석하기 위해서는 해당 연산자들의 <br>연산 횟수를 세면 되는 걸까? 답은 '아니다'.<br>

*알고리즘의 수행시간을 평가하기 위해서는 해당 알고리즘에 사용된 모든 연산의 횟수를 세는 것이 아니라, **중심이 되는 연산의 연산 횟수** 를 세야 한다!*<br>

그럼, 중심이 되는 연산이란 무엇인가? 탐색 알고리즘은 값을 비교하여 탐색하는 알고리즘이다. 즉, 해당 알고리즘에서의 핵심은 값을 비교하는 데에 있다. 이때, **`<`**, **`++`**, **`==`** 연산자 중, 값의 비교를 담당하는 연산자는 바로 **`==`** 연산자이고, **이 `==` 연산자를 이용한 값의 동등을 비교하는 연산이 해당 알고리즘의 중심이 되는 연산이라 할 수 있다.**<br>

이러한 중심이 되는 연산자는 다음과 같은 특징을 가진다. 
> 주변에 있는 연산자의 수행 횟수가 중심이 되는 연산자의 수행 횟수에 의존적이다. 즉, 중심이 되는 연산자의 수행 횟수에 따라 주변에 있는 연산자의 수행 횟수가 결정된다.<br>

위 코드를 보면, 배열 내에서 동등한 값을 찾지 못해, **`==`** 연산이 늘어나면 **`<`**, **`++`** 연산 또한 수행 횟수가 늘어나게 되고, 배열 내에서 동등한 값을 금방 찾아 **`==`** 연산 횟수가 줄어들게 되면  **`<`**, **`++`** 연산 또한 수행 횟수가 줄어들게 되는 것을 알 수 있다. 즉, 중심이 되는 **`==`** 연산의 수행 횟수에 주변 연산자들의 수행 횟수가 의존적인 것을 알 수 있다. 

### 순차탐색 알고리즘의 시간복잡도 분석하기 - 최선의 경우(best case), 최악의 경우(worst case), 평균적인 경우(average case)
모든 알고리즘에는 최선의 경우(best case), 최악의 경우(worst case), 평균적인 경우(average case) 가 존재한다. 순차탐색 알고리즘의 경우를 한번 보도록 하자.

### 최선의 경우(best case)
순차탐색 알고리즘의 시간 복잡도를 계산할 때 가장 최선의 경우는 무엇일까? 바로 해당 알고리즘의 중심이 되는 연산인 == 연산을 가장 적게하는 경우이다. 즉, **찾고자(탐색)하는 값을 배열의 첫 번째 요소(index 0) 에서 바로 찾은 경우** 라고 할 수 있겠다. == 연산을 한 번만 수행하면 되기 때문이다.<br>

그럼, 최선의 경우에서 순차탐색 알고리즘의 시간 복잡도를 계산해 보도록 하겠다.
