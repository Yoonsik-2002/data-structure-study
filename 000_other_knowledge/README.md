## Call-by-value 와 Call-by-reference
Call-by-value와 Call-by-reference는 **함수호출**과 관련된 개념이다. 

- #### Call-by-value
  Call-by-value는 함수호출 시, 단순히 값을 전달하는 형태의 함수호출을 의미하며 이 경우, 함수가 호출되면 **인자로 전달되는 변수의 값이(변수에 저장되어 있는 값이) 해당 함수의 매개변수에 복사되어 전달된다.**
  ```c
  ...
  void ex_func(int n) {
    ...
  }
  int main()
  {
    int num = 10;
    ex_func(num); // ex_func 함수가 호출되면 인자로 전달되는 변수 num에 저장되어 있는 값 10이 복사되어 해당 함수의 매개변수 n에 전달됨
    ...
  }
  ```
  다음 코드를 보면, 10 이라는 값을 저장하고 있는 int형 변수 **`num`** 이 함수 **`ex_func`** 에 인자로서 **`ex_func`** 의 매개변수 **`n`** 에 전달된다.<br>
  
  이 경우는 단순히 값을 전달하는 형태의 함수호출인 Call-by-value로, 해당 함수 호출이 일어나면 **인자로 전달되는 변수 num에 저장되어 있는 값 10이 복사되어 해당 함수의 매개변수 n에 전달되게 된다.**<br>
  
  이러한 경우에 발생하는 현상은 다음과 같다.<br>
  - 값이 복사되어 전달되기 때문에 인자로 전달된 변수 **`num`** 과 복사된 값을 전달받은 **`ex_func`** 의 매개변수 **`n`** 은 값은 같지만 별개의 변수가 된다. 즉, 둘은 별개의 변수이기 때문에 **`ex_func`** 에서 **`n`** 의 값을 변경하였다고 해서 **`num`** 의 값의 변경으로 이어지지 않는다. (매개변수의 값을 변경해도 원래의 전달된 변수의 값에는 영향을 미치지 않음)<br><br>
  - Call-by-value 형태의 함수에서는 함수 외부에 선언된 변수에 접근이 불가능하다. 이유는 위의 내용과 비슷하다. 애초에 단순히 (주소값을 제외한) 값이 전달되는 Call-by-value 함수의 매개변수에는 값이 복사되어 전달되기 때문에 함수 외부에 선언된 변수에 접근할 수 있는 방법이 존재하지 않는다. 
  복사되어 매개변수에 전달된 값의 주소값과 인자로서 전달된 값의 주소값은 다름!<br><br>
  ```c
  #include <stdio.h>

  void exfunc(int n) {
	  printf("매개변수 n에 저장된 값 : %d\n", n);
	  printf("매개변수 n의 주소값 : %p\n", &n);
  }

  int main()
  {
	  int n = 10;
	  printf("변수 n에 저장된 값 : %d\n", n);
	  printf("변수 n의 주소값 : %p\n", &n);
	  puts("");
	
	  exfunc(n);
  }
  ```
  ```c
  [실행결과]
  변수 n에 저장된 값 : 10
  변수 n의 주소값 : 0x7fff30c3f7a4

  매개변수 n에 저장된 값 : 10
  매개변수 n의 주소값 : 0x7fff30c3f78c
  ```
  
  
  
