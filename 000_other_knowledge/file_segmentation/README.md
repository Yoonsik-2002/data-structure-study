## 파일의 분할
프로그램을 작성하는데 있어, **파일 하나에 해당 프로그램에들어가는 모든 내용을 담는 경우,** 프로그램의 크기가 작을시에는 크게 
문제가 되지 않겠지만, **해당 프로그램의 크기가 커지면, 수정 또는 관리하기 어려워진다는 문제점이 발생한다.**<br>
~~(긴 프로그램의 모든 내용이 하나의 파일에 담겨있는 상황에서 해당 파일의 특정 부분을 찾아 수정하거나 관리하는 것은 당연히 어려운 일..)~~
<br><br>
이러한 문제를 해결할 수 있는 개념이 바로 **파일의 분할**이다. 파일의 분할을 설명하는데 있어 예시를 하나 들자면, 서랍장으로 할 수 있겠다. 
두 가지 종류의 서랍장이 있다고 가정해 보자.<br> 
하나는 수납공간이 통으로 하나인 **`서랍장 A`** , 다른 하나는 수납공간이 여러개로 분할되어 있는 **`서랍장 B`** 이다.
<br><br>
**`서랍장 A`** 의 경우, 수납 공간이 통으로 하나이기 때문에, 필기구든, 전자기기든, 의류든 상관없이 모두 한 공간에 정리해야 한다. 때문에, 
나중에 서랍장에서 특정 물건을 찾거나 정리할 때 등 서랍장 안의 물건을 관리하기가 불편하다는 단점이 생기게 된다. 

하지만, **`서랍장 B`** 의 경우, 수납공간이 여러개로 나누어져 있어, 필기구는 첫번째 칸에, 전자기기는 두번째 칸에, 의류는 세번째 칸에 등 물건의 용도나 특성 별로
나눠서 정리가 가능해지게 된다. 이럴 경우, 항목별로 수납공간이 나누어져 있어, 특정 물건을 쉽게 찾을 수 있게 되고, 정리 또한 수월하게 할 수 있게 된다.
즉, 물건 관리가 용이해지게 된다. 

자, 그럼 다시 파일 이야기로 넘어가 보자 파일은 프로그래밍에 있어, 위에서 설명한 서랍장과 같은 개념이라 생각하면 된다. **파일에 프로그램의 모든 내용을 한꺼번에 담는 것이 아니라, 파일을 나눠서 각각의 파일에 용도 및 특성 별로 함수와 변수를 나눠서 저장하면 소스코드의 관리가 용이해진다.**  
(파일은 서랍장과 같은 개념이고, 변수와 함수는 서랍장에 들어가는 물건들 이라 생각하면 이해가 편할 것이다.)
<br><br>
### 컴파일러의 특성과 `extern` 키워드

컴파일러의 특성은 **파일 단위로 컴파일을 진행한다**는 것이다. 쉽게말해, 지금 컴파일하고 있는 파일이 A 라고 하면, 파일 A 안에서만 해당 파일에서 사용하는 변수나 함수의 선언/정의를 찾는다는 뜻이다. <br>이때 당연히 다른 파일에서 선언된 변수나 함수들을 참조 할 수 없으며 이전에 앞서 컴파일 했었어도 지금 컴파일하고 있는 파일 이외의 파일에서 선언된 변수나 함수는 인지할 수 없다.

다음 소스코드와 파일 분할 예시를 통해 이해해보자. (헤더파일 선언은 각각의 파일에 적절히 이루어졌다고 가정) 
```c
[example01.c]
#include <stdio.h>

int num = 0;

void increment(void){
	num ++;
}

int get_num(void){
	return num;
}

int main()
{
	printf("Num : %d\n", get_num());
	increment();
	printf("Num : %d\n", get_num());
	increment();
	printf("Num : %d\n", get_num());
	increment();
}
```

#### [num.c]
```c
int num = 10;
```

#### [function.c]
```c
void increment(void){
	num ++;
}

int get_num(void){
	return num;
}
```

#### [main.c]
```c
int main()
{
	printf("Num : %d\n", get_num());
	increment();
	printf("Num : %d\n", get_num());
	increment();
	printf("Num : %d\n", get_num());
	increment();
}
```
위 코드를 보면, **`[example01.c]`** 소스 파일을 **`[num.c]`** , **`[function.c]`** , **`[main.c]`** 이렇게 3가지 파일로 분할하여 나타내었다. 이때, 이 분할된 파일은 컴파일시 에러가 나타나게 되는데 이유는 위에서 설명한 내용과 같다. 

먼저, 컴파일러는 위에서 설명했듯이, 파일 단위로 컴파일을 진행한다는 특성을 가지고 있다. **`[function.c]`** 파일을 보면, 파일 단위로 컴파일을 진행하는 컴파일러 입장에서는 **`[function.c]`** 파일 외부에서 선언된 **`num`** 이 도데체 어디에서 선언된 변수인지 인식하지 못한다. <br><br>
**즉, 컴파일러는 **`[function.c]`** 파일 안에서만 해당 파일 밖인 **`[num.c]`** 파일에 선언되어 있는 변수 **`num`** 의 선언을 찾게되기 때문에, 결국엔 찾지 못하고 에러 메세지를 출력하게 된다.**<br>
**`[main.c]`** 파일의 경우도 마찬가지이다. 해당 파일 외부에 정의된 함수 **`get_num()`** 을 자신이 컴파일 하고 있는 **`[main.c]`** 에서 계속 찾다가 결국엔 찾지 못하고 에러 메세지를 출력하게 된다.<br><br>

*그럼, 컴파일하고 있는 파일 외부에 선언(/정의)된 변수나 함수를 컴파일러가 알 수 있게 하는 방법은 없을까?*
<br><br>

파일 외부에 선언(/정의) 되어있는 변수나 함수를 컴파일러가 인지할 수 있게 하기 위해서는 **`extern`** 키워드를 사용하면 된다.<br>
- #### `[function.c]` 파일의 경우
	먼저, **`[function.c]`** 파일의 경우, 외부 파일 **`[num.c]`** 에서 선언된 변수 **`num`** 을 사용하기 때문에, 해당 변수의 선언에 대한 정보 (자료형이 무엇이고, 어디에 선언되어 있는지)를 컴파일러에게 알려주기 위해서 다음과 같은 방식으로 **`extern`** 키워드를 사용한다. 
	```c
	extern int num;
	```
	위 코드는 컴파일러에게 다음 내용을 전달하게 된다. *"`int`형 변수 `num`이 해당 파일 외부에 선언되어 있습니다 !"* 
<br>

- #### `[main.c]` 파일의 경우
	**`[main.c]`** 파일의 경우도 마찬가지이다. **`increment`** 함수가 **`[main.c]`** 파일 외부에 정의되어 있음을 컴파일러에게 알려주기 위해 다음과 같은 방식으로 **`extern`** 키워드를 사용한다. 
	```c
	extern void increment(void);
	```
	위 코드는 컴파일러에게 다음 내용을 전달하게 된다. *"`void increment(void)` 함수가 해당 파일 외부에 정의되어 있습니다 !"*<br>
	또, 함수가 외부에 정의 되어 있는것을 컴파일러에게 알리는 경우, 다음과 같이 **`extern`** 키워드를 생략해도 된다. 
	```c
	void increment(void);
	```<br>
	
**`extern`** 키워드를 사용하여 **`[example01.c]`** 파일의 분할을 바르게 수정하면 다음과 같다. 
```c
[num.c]
int num = 10;
```

```c
[function.c]
extern int num;

void increment() {
	num ++;
}

int get_num(void){
	return num;
}
```

```c
[main.c]
extern void increment(void); 
int get_num(void); // 파일 외부 함수의 정의를 컴파일러에게 알리는 경우, extern 키워드 생략가능

int main()
{
	printf("Num : %d\n", get_num());
	increment();
	printf("Num : %d\n", get_num());
	increment();
	printf("Num : %d\n", get_num());
	increment();
}
```
<br><br>
---
