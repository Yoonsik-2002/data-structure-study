## 매크로와 선행 처리
매크로와 선행처리에 대해 알아보자. 먼저, 선행처리란 무엇일까? 선행처리는 소스파일에서 실행파일을 생성하는 '실행파일 생성과정'의 여러 단계 중<br>
하나로, 컴파일을 하기전에 진행되는 과정이다.<br>
<br>


### 실행파일 생성 과정
실행파일은 '선행처리' 라는 과정을 거친 뒤, 컴파일과 링크의 과정을 거쳐서 만들어진다. 이 과정들을 통틀어 **실행파일 생성 과정** 이라 한다.<br>
각 과정에서 선행처리는 선행처리기에 의해, 컴파일은 컴파일러에 의해, 링크는 링커에 의해 진행된다. <br>

이러한 실행파일 생성과정을 그림으로 나타내면 다음과 같다.<br>

![B9190FFB-3D74-47CE-A4F0-9C5A7BF2125E](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/4308c4a0-7212-4afb-a40a-e7f0f7b11a3e)<br>

이 그림을 보면, 선행처리된 소스파일이 컴파일러를 거쳐, 컴파일 되면, 기존 소스파일은 컴퓨터가 읽을 수 있는 기계어로 번역되어, 바이너리 데이터로 <br>
이루어진 오브젝트 파일로 생성되는 것을 알 수 있다.<br>
그럼, 이전 단계인 맨 처음에 소스파일이 선행처리기를 통해 선행처리가 되면, 어떠한 형태의 파일로 생성될까?<br>

답은 선행처리 과정을 거치고 나서 생성된 소스파일 또한 그냥 소스파일일 뿐이다. 그럼 변화가 없는 것인가?<br>
아니다. 소스파일의 일부 내용이 소스파일 내, **선행처리 명령문** 대로 수정되게 된다.<br>
<br>

### 실행파일 생성과정 - 선행처리 과정
선행처리에서 '선행' 이란, 컴파일 과정 이전의 처리를 의미한다. 때문에, 선행처리 명령문은 '컴파일 과정 이전 단계인 선행처리 과정에서 선행처리기에 <br>
의해 처리되는 소스파일 내 명령문' 이라고 할 수 있겠다.<br>

아주 간단한 선행처리 명령문의 예시를 들어보겠다. 선행처리 명령문은 다음과 같은 형태를 띈다.<br>

**`#define  PI    3.14`**<br>

이처럼, 선행처리 명령문은 **`#`** 으로 시작하며, 컴파일러가 아닌 선행처리 과정에서 선행처리기에 의해 처리되는 명령문이기 때문에 끝에 세미콜론(**`;`**)<br>
이 붙지 않는다.<br>

그럼, 위의 선행처리 명령문의 예시가 의미하는 바는 무엇일까? 바로, *'해당 소스파일 내에서 `PI` 를 만나게 되면 무조건 3.14로 치환 하세요!'*<br>
라는 의미이다.<br> 

이러한 선행처리 명령문이 포함되어 있는 소스파일은 실행파일의 생성 과정 중, 선행 처리 과정에서 다음 그림과 같은 방식으로 변환되게 된다.<br>

![69C9A1F5-6CAC-41E2-81CE-DE7061683C21](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/f1be3112-a3ac-414f-bc40-3a60b7c29ec8)<br>

소스파일이 선행처리기에 의해 선행처리 되면서, `PI`는 3.14로 치환되고, 소스파일 상단에 있던 선행처리 명령문은 사라지게 된다.<br>

> `#include <stdio.h>` 또한 선행처리 명령문이다.<br>
  `stdio.h`파일은 C언어가 기본적으로 제공하는 표준 라이브러리 내에서, 표준 입출력(Standard Input/Output)에 대한 선언을 모아놓은 헤더파일이다.<br>
  이 `#include <stdio.h>` 선행처리 명령문은 `stdio.h` 파일의 내용을 해당 명령문의 위치에 가져다 놓으라는 뜻이 된다.<br>
  결국 stdio.h 파일 안의 내용을 그대로 `#include <stdio.h>` 선행처리 명령문의 위치에 옮겨다 놓는 것이랑 똑같은 효과가 일어나게 된다!<br>











