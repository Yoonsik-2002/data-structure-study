## 매크로와 선행 처리
매크로와 선행처리에 대해 알아보자. 먼저, 선행처리란 무엇일까? 선행처리는 소스파일에서 실행파일을 생성하는 '실행파일 생성과정'의 여러 단계 중<br>
하나로, 컴파일을 하기전에 진행되는 과정이다.<br>
<br>


### 실행파일 생성 과정
실행파일은 '선행처리' 라는 과정을 거친 뒤, 컴파일과 링크의 과정을 거쳐서 만들어진다. 이 과정들을 통틀어 **실행파일 생성 과정** 이라 한다.<br>
각 과정에서 선행처리는 선행처리기에 의해, 컴파일은 컴파일러에 의해, 링크는 링커에 의해 진행된다. <br>

이러한 실행파일 생성과정을 그림으로 나타내면 다음과 같다.<br>

![B9190FFB-3D74-47CE-A4F0-9C5A7BF2125E](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/4308c4a0-7212-4afb-a40a-e7f0f7b11a3e)<br>

이 그림을 보면, 선행처리된 소스파일이 컴파일러를 거쳐, 컴파일 되면, 기존 소스파일은 컴퓨터가 읽을 수 있는 기계어로 번역되어, 바이너리 데이터로 <br>
이루어진 오브젝트 파일로 생성되는 것을 알 수 있다.<br>
그럼, 이전 단계인 맨 처음에 소스파일이 선행처리기를 통해 선행처리가 되면, 어떠한 형태의 파일로 생성될까?<br>

답은 선행처리 과정을 거치고 나서 생성된 소스파일 또한 그냥 소스파일일 뿐이다. 그럼 변화가 없는 것인가?<br>
아니다. 소스파일의 일부 내용이 소스파일 내, **선행처리 명령문** 대로 수정되게 된다.<br>
<br>

### 실행파일 생성과정 - 선행처리 과정
선행처리에서 '선행' 이란, 컴파일 과정 이전의 처리를 의미한다. 때문에, 선행처리 명령문은 '컴파일 과정 이전 단계인 선행처리 과정에서 선행처리기에 <br>
의해 처리되는 소스파일 내 명령문' 이라고 할 수 있겠다.<br>

아주 간단한 선행처리 명령문의 예시를 들어보겠다. 선행처리 명령문은 다음과 같은 형태를 띈다.<br>

**`#define  PI   3.14`**<br>

이처럼, 선행처리 명령문은 **`#`** 으로 시작하며, 컴파일러가 아닌 선행처리 과정에서 선행처리기에 의해 처리되는 명령문이기 때문에 끝에 세미콜론(**`;`**)<br>
이 붙지 않는다.<br>

그럼, 위의 선행처리 명령문의 예시가 의미하는 바는 무엇일까? 바로, *'해당 소스파일 내에서 `PI` 를 만나게 되면 무조건 3.14로 치환 하세요!'*<br>
라는 의미이다.<br> 

이러한 선행처리 명령문이 포함되어 있는 소스파일은 실행파일의 생성 과정 중, 선행 처리 과정에서 다음 그림과 같은 방식으로 변환되게 된다.<br>

![69C9A1F5-6CAC-41E2-81CE-DE7061683C21](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/f1be3112-a3ac-414f-bc40-3a60b7c29ec8)<br>

소스파일이 선행처리기에 의해 선행처리 되면서, `PI`는 3.14로 치환되고, 소스파일 상단에 있던 선행처리 명령문은 사라지게 된다.<br>

> `#include <stdio.h>` 또한 선행처리 명령문이다.<br>
  `stdio.h`파일은 C언어가 기본적으로 제공하는 표준 라이브러리 내에서, 표준 입출력(Standard Input/Output)에 대한 선언을 모아놓은 헤더파일이다.<br>
  이 `#include <stdio.h>` 선행처리 명령문은 `stdio.h` 파일의 내용을 해당 명령문의 위치에 가져다 놓으라는 뜻이 된다.<br>
  결국 stdio.h 파일 안의 내용을 그대로 `#include <stdio.h>` 선행처리 명령문의 위치에 옮겨다 놓는 것이랑 똑같은 효과가 일어나게 된다!<br>
  
<br><br>

## 선행처리 명령문
선행처리가 무엇인지 알아보았으니, 선행처리 시, 선행처리기가 처리하게 되는 선행처리 명령문에 대해 알아보도록 하겠다.<br>
<br>

### `#define: Object-like macro`(오프젝트와 유사한 매크로, 매크로 상수)
위에서 앞서 정의한 선행처리 명령문(`#define  PI   3.1415`)을 가지고 선행처리 명령문의 구성에 대해 알아보도록 하겠다.<br>
선행처리 명령문의 구조는 아래 그림과 같다.<br>

![E3DEFDF2-F39F-4BB8-A948-10CF0EFCA3B1](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/3166cd40-6924-47b8-aadc-69e924d89528)<br>

먼저, 선행처리 명령문에서 첫 번째로 등장하는 `#define`을 가리켜, '지시자'라고 부른다. 컴파일 전, 선행처리를 수행하는 선행처리기가<br>
이 '지시자'를 보고 프로그래머가 지시하는 바를 파악한다.<br>

위 선행처리 명령문에서 지시자 `#define`은 선행처리기에게 다음과 같은 프로그래머의 지시를 전달한다.<br>
*'이어서 나오는 매크로를 매크로 몸체로 치환해라'*<br>

그리고, 지시자 다음으로 선행처리 명령문을 구성하는 요소 2가지를 각각 순서대로 '매크로', '매크로 몸체' 라고 한다. <br>
따라서 결론적으로, 위 선행처리 명령문은 선행처리기에 다음과 같은 지시를 하게 된다.<br>
*'매크로 `PI`를 메크로 몸체 3.1415로 전부 치환해라'*<br>

결과적으로 매크로 `PI`는 그 자체로 변경할 수 없는 상수 3.1415가 된다. 이러한 매크로(여기서는 `PI`)를 가리켜, **오브젝트와 유사한 매크로**, <br>
또는 간단하게 **매크로 상수** 라고 한다.<br>

이러한 매크로의 이름은 일반적으로, 대문자로 정의한다. 대문자로 정의함으로써 이 식별자가 매크로라는 사실을 부각시킬 수 있기 때문이다.<br>
<br>

### `#define: Function-like macro`(함수와 유사한 매크로, 매크로 함수)



















