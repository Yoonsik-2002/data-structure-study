## 매크로와 선행 처리
매크로와 선행처리에 대해 알아보자. 먼저, 선행처리란 무엇일까? 선행처리는 소스파일에서 실행파일을 생성하는 '실행파일 생성과정'의 여러 단계 중<br>
하나로, 컴파일을 하기전에 진행되는 과정이다.<br>
<br>


### 실행파일 생성 과정
실행파일은 '선행처리' 라는 과정을 거친 뒤, 컴파일과 링크의 과정을 거쳐서 만들어진다. 이 과정들을 통틀어 **실행파일 생성 과정** 이라 한다.<br>
각 과정에서 선행처리는 선행처리기에 의해, 컴파일은 컴파일러에 의해, 링크는 링커에 의해 진행된다. <br>

이러한 실행파일 생성과정을 그림으로 나타내면 다음과 같다.<br>

![B9190FFB-3D74-47CE-A4F0-9C5A7BF2125E](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/4308c4a0-7212-4afb-a40a-e7f0f7b11a3e)<br>

이 그림을 보면, 선행처리된 소스파일이 컴파일러를 거쳐, 컴파일 되면, 기존 소스파일은 컴퓨터가 읽을 수 있는 기계어로 번역되어, 바이너리 데이터로 <br>
이루어진 오브젝트 파일로 생성되는 것을 알 수 있다.<br>
그럼, 이전 단계인 맨 처음에 소스파일이 선행처리기를 통해 선행처리가 되면, 어떠한 형태의 파일로 생성될까?<br>

답은 선행처리 과정을 거치고 나서 생성된 소스파일 또한 그냥 소스파일일 뿐이다. 그럼 변화가 없는 것인가?<br>
아니다. 소스파일의 일부 내용이 소스파일 내, **선행처리 명령문** 대로 수정되게 된다.<br>
<br>

### 실행파일 생성과정 - 선행처리 과정
선행처리에서 '선행' 이란, 컴파일 과정 이전의 처리를 의미한다. 때문에, 선행처리 명령문은 '컴파일 과정 이전 단계인 선행처리 과정에서 선행처리기에 <br>
의해 처리되는 소스파일 내 명령문' 이라고 할 수 있겠다.<br>

아주 간단한 선행처리 명령문의 예시를 들어보겠다. 선행처리 명령문은 다음과 같은 형태를 띈다.<br>

**`#define  PI   3.14`**<br>

이처럼, 선행처리 명령문은 **`#`** 으로 시작하며, 컴파일러가 아닌 선행처리 과정에서 선행처리기에 의해 처리되는 명령문이기 때문에 끝에 세미콜론(**`;`**)<br>
이 붙지 않는다.<br>

그럼, 위의 선행처리 명령문의 예시가 의미하는 바는 무엇일까? 바로, *'해당 소스파일 내에서 `PI` 를 만나게 되면 무조건 3.14로 치환 하세요!'*<br>
라는 의미이다.<br> 

이러한 선행처리 명령문이 포함되어 있는 소스파일은 실행파일의 생성 과정 중, 선행 처리 과정에서 다음 그림과 같은 방식으로 변환되게 된다.<br>

![69C9A1F5-6CAC-41E2-81CE-DE7061683C21](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/f1be3112-a3ac-414f-bc40-3a60b7c29ec8)<br>

소스파일이 선행처리기에 의해 선행처리 되면서, `PI`는 3.14로 치환되고, 소스파일 상단에 있던 선행처리 명령문은 사라지게 된다.<br>

> `#include <stdio.h>` 또한 선행처리 명령문이다.<br>
  `stdio.h`파일은 C언어가 기본적으로 제공하는 표준 라이브러리 내에서, 표준 입출력(Standard Input/Output)에 대한 선언을 모아놓은 헤더파일이다.<br>
  이 `#include <stdio.h>` 선행처리 명령문은 `stdio.h` 파일의 내용을 해당 명령문의 위치에 가져다 놓으라는 뜻이 된다.<br>
  결국 stdio.h 파일 안의 내용을 그대로 `#include <stdio.h>` 선행처리 명령문의 위치에 옮겨다 놓는 것이랑 똑같은 효과가 일어나게 된다!<br>
  
<br><br>

## 선행처리 명령문
선행처리가 무엇인지 알아보았으니, 선행처리 시, 선행처리기가 처리하게 되는 선행처리 명령문에 대해 알아보도록 하겠다.<br>
<br>

### `#define: Object-like macro`(오프젝트와 유사한 매크로, 매크로 상수)
위에서 앞서 정의한 선행처리 명령문(`#define  PI   3.1415`)을 가지고 선행처리 명령문의 구성에 대해 알아보도록 하겠다.<br>
선행처리 명령문의 구조는 아래 그림과 같다.<br>

![E3DEFDF2-F39F-4BB8-A948-10CF0EFCA3B1](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/3166cd40-6924-47b8-aadc-69e924d89528)<br>

먼저, 선행처리 명령문에서 첫 번째로 등장하는 `#define`을 가리켜, '지시자'라고 부른다. 컴파일 전, 선행처리를 수행하는 선행처리기가<br>
이 '지시자'를 보고 프로그래머가 지시하는 바를 파악한다. (이러한 매크로 지시자는 #define 말고도 여러 종류가 존재한다!)<br>

위 선행처리 명령문에서 매크로를 정의하는 역할을 하는 지시자 `#define`은 선행처리기에게 다음과 같은 프로그래머의 지시를 전달한다.<br>
*'이어서 나오는 매크로를 매크로 몸체로 치환해라'*<br>

그리고, 지시자 다음으로 선행처리 명령문을 구성하는 요소 2가지를 각각 순서대로 '매크로', '매크로 몸체' 라고 한다. <br>
따라서 결론적으로, 위 선행처리 명령문은 선행처리기에 다음과 같은 지시를 하게 된다.<br>
*'매크로 `PI`를 메크로 몸체 3.1415로 전부 치환해라'*<br>

결과적으로 매크로 `PI`는 그 자체로 변경할 수 없는 상수 3.1415가 된다. 이러한 매크로(여기서는 `PI`)를 가리켜, **오브젝트와 유사한 매크로**, <br>
또는 간단하게 **매크로 상수** 라고 한다.<br>

이러한 매크로의 이름은 일반적으로, 대문자로 정의한다. 대문자로 정의함으로써 이 식별자가 매크로라는 사실을 부각시킬 수 있기 때문이다.<br>
<br>

### `#define: Function-like macro`(함수와 유사한 매크로, 매크로 함수)
매크로는 매개변수가 있는 형태로도 선언이 가능하다. 이렇게 매개변수가 있는 매크로의 경우, 작동방식이 함수와 유사하여, Function-like macro,<br>
함수와 유가한 매크로 혹은 매크로 함수 라고 부른다.<br>

매크로 함수의 예는 아래 그림과 같다.<br>

![D1B0B4F9-FD09-402F-BB0F-B6126AA85AC2](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/3daf6128-1163-48b7-9704-0ae81df1bda4)<br>

이렇게 정의된 매크로를 접한 선행처리기는 *'`SQUARE(X)`와 같은 패턴을 만나면 `X*X` 로 치환해라!'* 라는 프로그래머의 지시를 매크로를 통해<br>
전달받고, 그대로 `SQUARE(X)`와 같은 패턴을 만나게 되면, `X*X` 로 치환해 버린다.<br>

이런 `SQUARE(X)` 매크로가 정의된 후, 선행처리 과정에 선행처리기가 다음과 같은 매크로 함수를 만나게 되면, 그 다음 아래 그림과 같은 변환이 일어난다.<br>
```c
SQUARE(10);
SQUARE(num);
```
<br>

![25104E05-D460-406A-A375-983823FD3E91](https://github.com/Yoonsik-2002/data-structure-study/assets/83572199/f85b7fc3-7e6a-472c-b10e-ec0936818c4f)<br>

이렇게 선행처리기에 의해서 변환되는 과정 자체를 **매크로 확장(Macro Expansion)** 이라고 한다.<br>
<br>

### 매크로 함수 정의시 주의할 점
다음은 이 매크로 함수를 이용한 간단한 프로그램이다. 해당 프로그램에서는 비정상적인 출력이 일어나는데 해당 이유를 분석해보도록 하겠다.<br>
```c
#include <stdio.h>

#define SQUARE(X) X*X

void main()
{
	int num = 7;
	
	// 정상적인 출력
	printf("square of num : %d\n", SQUARE(num));
	printf("square of 20 : %d\n", SQUARE(20));
	printf("square of -5 : %d\n", SQUARE(-5));
	
	// 비정상적인 출력
	printf("square of 3+5 : %d\n", SQUARE(3+5));
}
```
*[macro_function.c 의 실행결과]*
```
square of num : 49
square of 20 : 400
square of -5 : 25
square of 3+5 : 23
```

위 코드에서, 비정상적인 출력이 일어난 `printf("square of 3+5 : %d\n", SQUARE(3+5));` 코드에 주목해 보겠다.<br>
매크로 함수 `SQUARE(3+5)`를 우리가 잘 아는 일반 함수의 관점으로 보면, 인자로 전달되는 `3+5`는 먼저 선행처리기에 의해 계산이 되어,<br>
8로 `SQUARE` 함수에 전달이 되어야 한다.<br>
그리고, `SQUARE(8)`과 같은 패턴은 위에서 선언된 대로 `8*8`로 치환되어, 결과는 `64`가 나와야 한다.<br>
하지만, 해당 매크로 함수의 결과는 보다시피, `23`이 된다. 어떻게 이런 결과가 나온 것일까?<br>

답은 **선행처리기의 역할**에 있다. 위에서 함수의 관점으로 매크로 함수 `SQUARE(3+5)`를 설명하였을 때, 인자로 전달되는 `3+5`는 선행처리기에 의해<br>
계산이 된다고 하였다. 이 설명은 틀린설명이다!<br>

**위 설명과 같이 함수의 인자로 전달된 수식을 미리 계산하고, 해당 연산 결과를 가지고 함수를 호출해주는 것은 컴파일러의 역할이지, 선행처리기가<br>
수행하는 역할이 아니다!**<br>

선행처리기는 매크로 함수가 선언된 대로 어떠한 패턴(`매개변수가 있는 매크로(매크로 함수)`)을 미리 정의한 수식(`매크로 몸체`)으로 치환해줄 뿐이지,<br>
컴파일러처럼 전달된 수식 형태의 인자를 미리 계산하여 함수를 호출해주지 않는다.<br>

결국, 실질적으로 해당 코드에서 매크로 함수 `SQUARE(3+5)`는 선행처리기에 의해 아래와 같은 수식으로 치환되게 된다. <br>
```c
3+5*3+5
```
이러한 이유 때문에, `SQUARE(3+5)`의 결과가 `23`이 나오게 된것이다.<br>

그렇다면, 매크로 함수 `SQUARE(3+5)`의 결과가 우리가 의도한 `64`가 되도록 하려면 어떻게 해야 할까?<br>
먼저, 첫 번째로 가장 단순한 방법으로는 `SQUARE((3+5))`로 호출해주면, 해당 매크로 함수는 실행파일 생성 과정에서, 선행처리기에 의해<br>
`(3+5)*(3+5)` 로 치환되어 `64`라는 결과가 나오게 된다.<br> 

하지만 이러한 방법은 안정적인 형태라 할 수 없다.<br>

그렇다면, 애초에 `SQUARE`함수를 정의할 때 매크로 몸체에 괄호처리를 한 상태로 정의해보면 어떨까?<br>
아래와 같이 정의해 보면, 이미 매크로 몸체에 괄호처리가 되어있기 때문에 `SQUARE(3+5)`로 호출해도 `64`라는 결과를 얻을 수 있다.<br>
```c
#define  SQUARE(X)   (X)*(X)
```
하지만, 위 코드도 완벽한 해답은 아니다.<br>

예를 들어보겠다. `int num = 120 / SQUARE(1+1)`의 경우, 변수 `num`에는 우리가 의도한 `30`이 초기화 되는 것이 아니라, `120`이 초기화 된다.<br>
이유는 다음과 같다. 해당 매크로 함수 선행처리기에 의해서 매크로 몸체로 치환되면, 다음과 같은 수식이 이루어진다.<br>
```c
int num = 120 / (1+1)*(1+1);
```
120을 2로 나누고, 다시 2를 곱해주는 꼴이 되는 것이다.<br>

이러한 문제를 해결하기 위해서는 **매크로 함수를 정의할 때 매크로 몸체를 구성하는 요소(전달인자)마다 괄호처리를 해 주고, 메크로 몸체 전체에 한번 더 
괄호를 쳐 주어야 한다.**<br>

최종적으로 이러한 규칙을 반영하여 매크로 함수 `SQUARE`을 정의하면 다음과 같다.<br>
```c
#define  SQUARE(X)   ((X)*(X))
```
이렇게 정의해둔 상태에서 문제의 `int num = 120 / SQUARE(1+1)`은 선행처리기에 의해 아래와 같은 코드를 완성하게 되고, 변수 `num`에는 `30`이<br>
초기화 되게 된다.<br>
```c
int num = 120 / ((1+1)*(1+1));
```
> **매크로 함수를 정의할 때에는 매크로 몸체를 구성하는 요소(전달인자, 이번 예시에서는 `X`)마다 괄호처리를 해 주고, 메크로 몸체 전체를 한번 더 
괄호로 묶어 주어야 한다는 것을 잊지 말자!**<br>
<br>






























